{
    "id": 8,
    "name": "Java Collections Framework - List",
    "description": "List interface, ArrayList, LinkedList, Vector, list operations, and performance characteristics in Java.",
    "proLocked": false,
    "isActive": true,
    "orderIndex": 7,
    "questions": [
        {
            "id": 1,
            "title": "List Interface Basics",
            "description": "What is the List interface in Java Collections Framework?",
            "code": "List<String> list = new ArrayList<>();\nlist.add(\"Hello\");\nlist.add(\"World\");",
            "options": [
                "An ordered collection that allows duplicates",
                "A sorted collection without duplicates",
                "A key-value pair collection",
                "A thread-safe collection"
            ],
            "correct": 0,
            "explanation": "List is an ordered collection (sequence) that allows duplicate elements and provides positional access to elements."
        },
        {
            "id": 2,
            "title": "ArrayList vs LinkedList",
            "description": "What is the main difference between ArrayList and LinkedList?",
            "code": "List<Integer> arrayList = new ArrayList<>();\nList<Integer> linkedList = new LinkedList<>();",
            "options": [
                "ArrayList is thread-safe, LinkedList is not",
                "ArrayList uses array, LinkedList uses doubly-linked nodes",
                "ArrayList allows duplicates, LinkedList doesn't",
                "No significant difference"
            ],
            "correct": 1,
            "explanation": "ArrayList uses a resizable array internally, while LinkedList uses a doubly-linked list structure with nodes."
        },
        {
            "id": 3,
            "title": "ArrayList Performance",
            "description": "What is the time complexity for random access in ArrayList?",
            "code": "ArrayList<String> list = new ArrayList<>();\nString element = list.get(100); // Random access",
            "options": [
                "O(1)",
                "O(log n)",
                "O(n)",
                "O(n²)"
            ],
            "correct": 0,
            "explanation": "ArrayList provides O(1) random access because it uses an underlying array where elements can be accessed directly by index."
        },
        {
            "id": 4,
            "title": "LinkedList Performance",
            "description": "What is the time complexity for insertion at the beginning of LinkedList?",
            "code": "LinkedList<String> list = new LinkedList<>();\nlist.addFirst(\"First\"); // Insert at beginning",
            "options": [
                "O(1)",
                "O(log n)",
                "O(n)",
                "O(n²)"
            ],
            "correct": 0,
            "explanation": "LinkedList provides O(1) insertion at the beginning because it maintains references to both head and tail nodes."
        },
        {
            "id": 5,
            "title": "Vector vs ArrayList",
            "description": "What is the main difference between Vector and ArrayList?",
            "code": "Vector<String> vector = new Vector<>();\nArrayList<String> arrayList = new ArrayList<>();",
            "options": [
                "Vector is faster",
                "Vector is synchronized (thread-safe)",
                "Vector uses less memory",
                "Vector doesn't allow null values"
            ],
            "correct": 1,
            "explanation": "Vector is synchronized (thread-safe) while ArrayList is not. Vector is legacy and generally ArrayList is preferred."
        },
        {
            "id": 6,
            "title": "List Initialization",
            "description": "Which is a valid way to initialize a List with values?",
            "code": "List<String> list = Arrays.asList(\"A\", \"B\", \"C\");\n// or\nList<String> list2 = List.of(\"A\", \"B\", \"C\"); // Java 9+",
            "options": [
                "Arrays.asList()",
                "List.of() (Java 9+)",
                "Collections.singletonList()",
                "All of the above"
            ],
            "correct": 3,
            "explanation": "All are valid ways to initialize lists: Arrays.asList() creates a fixed-size list, List.of() creates immutable list, Collections.singletonList() creates single-element list."
        },
        {
            "id": 7,
            "title": "List Capacity and Size",
            "description": "What happens when ArrayList exceeds its initial capacity?",
            "code": "ArrayList<Integer> list = new ArrayList<>(10); // Initial capacity 10\n// Adding 11th element",
            "options": [
                "Throws exception",
                "Automatically resizes (grows)",
                "Overwrites first element",
                "Ignores the addition"
            ],
            "correct": 1,
            "explanation": "ArrayList automatically resizes when capacity is exceeded, typically growing by 50% of current capacity."
        },
        {
            "id": 8,
            "title": "List Iterator",
            "description": "What is the advantage of ListIterator over Iterator?",
            "code": "List<String> list = new ArrayList<>();\nListIterator<String> listIter = list.listIterator();\n// Can traverse in both directions",
            "options": [
                "Faster iteration",
                "Bidirectional traversal",
                "Thread-safe iteration",
                "Automatic sorting"
            ],
            "correct": 1,
            "explanation": "ListIterator allows bidirectional traversal (forward and backward) and provides additional methods like previous(), hasPrevious(), and set()."
        },
        {
            "id": 9,
            "title": "Sublist Operation",
            "description": "What does the subList() method return?",
            "code": "List<Integer> original = Arrays.asList(1, 2, 3, 4, 5);\nList<Integer> sub = original.subList(1, 4); // [2, 3, 4]",
            "options": [
                "A new independent list",
                "A view of the original list",
                "A sorted portion",
                "An immutable list"
            ],
            "correct": 1,
            "explanation": "subList() returns a view of the original list. Changes to the sublist are reflected in the original list and vice versa."
        },
        {
            "id": 10,
            "title": "List Equality",
            "description": "When are two Lists considered equal?",
            "code": "List<String> list1 = Arrays.asList(\"A\", \"B\", \"C\");\nList<String> list2 = Arrays.asList(\"A\", \"B\", \"C\");\nboolean equal = list1.equals(list2); // true",
            "options": [
                "Same reference",
                "Same elements in same order",
                "Same size only",
                "Same implementation type"
            ],
            "correct": 1,
            "explanation": "Two Lists are equal if they contain the same elements in the same order, regardless of their implementation types."
        },
        {
            "id": 11,
            "title": "Collections.sort()",
            "description": "What does Collections.sort() do to a List?",
            "code": "List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5);\nCollections.sort(numbers);\n// Result: [1, 1, 3, 4, 5]",
            "options": [
                "Creates a new sorted list",
                "Sorts the list in-place",
                "Returns a sorted view",
                "Throws exception for duplicates"
            ],
            "correct": 1,
            "explanation": "Collections.sort() sorts the list in-place, modifying the original list. Elements must implement Comparable or a Comparator must be provided."
        },
        {
            "id": 12,
            "title": "List.removeIf()",
            "description": "What does the removeIf() method do? (Java 8+)",
            "code": "List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));\nnumbers.removeIf(n -> n % 2 == 0);\n// Result: [1, 3, 5]",
            "options": [
                "Removes first matching element",
                "Removes all matching elements",
                "Removes elements at even indices",
                "Creates filtered copy"
            ],
            "correct": 1,
            "explanation": "removeIf() removes all elements that match the given predicate condition from the list."
        },
        {
            "id": 13,
            "title": "ConcurrentModificationException",
            "description": "When does ConcurrentModificationException occur?",
            "code": "List<String> list = new ArrayList<>(Arrays.asList(\"A\", \"B\", \"C\"));\nfor (String item : list) {\n    if (item.equals(\"B\")) {\n        list.remove(item); // Throws exception\n    }\n}",
            "options": [
                "When accessing from multiple threads",
                "When modifying list during iteration",
                "When list is empty",
                "When using wrong iterator"
            ],
            "correct": 1,
            "explanation": "ConcurrentModificationException occurs when a list is structurally modified during iteration (except through the iterator's own methods)."
        },
        {
            "id": 14,
            "title": "Safe Removal During Iteration",
            "description": "How do you safely remove elements while iterating?",
            "code": "List<String> list = new ArrayList<>(Arrays.asList(\"A\", \"B\", \"C\"));\nIterator<String> iter = list.iterator();\nwhile (iter.hasNext()) {\n    if (iter.next().equals(\"B\")) {\n        iter.remove(); // Safe removal\n    }\n}",
            "options": [
                "Use enhanced for loop",
                "Use Iterator.remove()",
                "Use Collections.remove()",
                "Use synchronized block"
            ],
            "correct": 1,
            "explanation": "Use Iterator.remove() method to safely remove elements during iteration without causing ConcurrentModificationException."
        },
        {
            "id": 15,
            "title": "List to Array Conversion",
            "description": "What is the correct way to convert List to array?",
            "code": "List<String> list = Arrays.asList(\"A\", \"B\", \"C\");\nString[] array = list.toArray(new String[0]);",
            "options": [
                "list.toArray()",
                "list.toArray(new String[0])",
                "list.toArray(new String[list.size()])",
                "Both B and C"
            ],
            "correct": 3,
            "explanation": "Both toArray(new String[0]) and toArray(new String[list.size()]) work correctly. The first is preferred for performance in modern JVMs."
        },
        {
            "id": 16,
            "title": "ArrayList Initial Capacity",
            "description": "What is the default initial capacity of ArrayList?",
            "code": "ArrayList<String> list = new ArrayList<>(); // Default capacity",
            "options": [
                "0",
                "10",
                "16",
                "32"
            ],
            "correct": 1,
            "explanation": "ArrayList has a default initial capacity of 10 elements. You can specify a different initial capacity in the constructor."
        },
        {
            "id": 17,
            "title": "LinkedList as Deque",
            "description": "What additional interface does LinkedList implement?",
            "code": "LinkedList<String> list = new LinkedList<>();\nlist.addFirst(\"First\");\nlist.addLast(\"Last\");\nString first = list.removeFirst();",
            "options": [
                "Queue",
                "Deque",
                "Stack",
                "All of the above"
            ],
            "correct": 3,
            "explanation": "LinkedList implements Deque interface, which extends Queue. It can be used as a double-ended queue, queue, or stack."
        },
        {
            "id": 18,
            "title": "List.replaceAll()",
            "description": "What does the replaceAll() method do? (Java 8+)",
            "code": "List<String> words = new ArrayList<>(Arrays.asList(\"hello\", \"world\"));\nwords.replaceAll(String::toUpperCase);\n// Result: [\"HELLO\", \"WORLD\"]",
            "options": [
                "Replaces specific elements",
                "Applies function to all elements",
                "Removes and adds elements",
                "Sorts elements"
            ],
            "correct": 1,
            "explanation": "replaceAll() applies the given function to each element and replaces each element with the result of applying the function."
        },
        {
            "id": 19,
            "title": "Immutable Lists",
            "description": "How do you create an immutable List? (Java 9+)",
            "code": "List<String> immutable = List.of(\"A\", \"B\", \"C\");\n// immutable.add(\"D\"); // Throws UnsupportedOperationException",
            "options": [
                "Collections.unmodifiableList()",
                "List.of()",
                "ImmutableList.of()",
                "Both A and B"
            ],
            "correct": 3,
            "explanation": "Both Collections.unmodifiableList() and List.of() create immutable lists. List.of() is more convenient and was introduced in Java 9."
        },
        {
            "id": 20,
            "title": "List Performance Comparison",
            "description": "Which operation is faster in LinkedList than ArrayList?",
            "code": "// ArrayList: O(n) for insertion in middle\n// LinkedList: O(1) if you have iterator position",
            "options": [
                "Random access by index",
                "Insertion at middle (with iterator)",
                "Memory usage",
                "Iteration through all elements"
            ],
            "correct": 1,
            "explanation": "LinkedList is faster for insertion/deletion in the middle when you have an iterator at the position, as it's O(1) vs ArrayList's O(n)."
        },
        {
            "id": 21,
            "title": "List.indexOf() and lastIndexOf()",
            "description": "What do indexOf() and lastIndexOf() methods return?",
            "code": "List<String> list = Arrays.asList(\"A\", \"B\", \"A\", \"C\");\nint first = list.indexOf(\"A\");     // 0\nint last = list.lastIndexOf(\"A\");  // 2",
            "options": [
                "Element at index",
                "Index of element",
                "Number of occurrences",
                "Boolean presence"
            ],
            "correct": 1,
            "explanation": "indexOf() returns the index of the first occurrence, lastIndexOf() returns the index of the last occurrence. Both return -1 if not found."
        },
        {
            "id": 22,
            "title": "List.addAll() Method",
            "description": "What does the addAll() method do?",
            "code": "List<String> list1 = new ArrayList<>(Arrays.asList(\"A\", \"B\"));\nList<String> list2 = Arrays.asList(\"C\", \"D\");\nlist1.addAll(list2);\n// Result: [\"A\", \"B\", \"C\", \"D\"]",
            "options": [
                "Merges two lists into new list",
                "Adds all elements from another collection",
                "Adds elements only if not present",
                "Sorts and adds elements"
            ],
            "correct": 1,
            "explanation": "addAll() adds all elements from the specified collection to the end of the list (or at specified index with addAll(index, collection))."
        },
        {
            "id": 23,
            "title": "List.retainAll() Method",
            "description": "What does the retainAll() method do?",
            "code": "List<Integer> list1 = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));\nList<Integer> list2 = Arrays.asList(2, 4, 6);\nlist1.retainAll(list2);\n// Result: [2, 4]",
            "options": [
                "Adds common elements",
                "Keeps only common elements",
                "Removes common elements",
                "Merges unique elements"
            ],
            "correct": 1,
            "explanation": "retainAll() keeps only elements that are contained in the specified collection, effectively computing the intersection."
        },
        {
            "id": 24,
            "title": "List Memory Overhead",
            "description": "Which List implementation has the least memory overhead per element?",
            "code": "// ArrayList: Only stores references in array\n// LinkedList: Stores data + two pointers per node",
            "options": [
                "ArrayList",
                "LinkedList",
                "Vector",
                "All are equal"
            ],
            "correct": 0,
            "explanation": "ArrayList has the least memory overhead as it only stores object references in an array, while LinkedList needs additional memory for node pointers."
        },
        {
            "id": 25,
            "title": "List.clear() vs new ArrayList()",
            "description": "What's the difference between clear() and creating new ArrayList?",
            "code": "list.clear();                    // Option A\nlist = new ArrayList<>();        // Option B",
            "options": [
                "No difference",
                "clear() reuses capacity, new creates fresh instance",
                "clear() is slower",
                "new is always better"
            ],
            "correct": 1,
            "explanation": "clear() removes all elements but keeps the underlying array capacity, while new ArrayList() creates a fresh instance with default capacity."
        },
        {
            "id": 26,
            "title": "List.contains() Performance",
            "description": "What is the time complexity of contains() method in ArrayList?",
            "code": "ArrayList<String> list = new ArrayList<>();\nboolean found = list.contains(\"target\"); // Linear search",
            "options": [
                "O(1)",
                "O(log n)",
                "O(n)",
                "O(n²)"
            ],
            "correct": 2,
            "explanation": "contains() method performs a linear search through the list, resulting in O(n) time complexity for both ArrayList and LinkedList."
        },
        {
            "id": 27,
            "title": "List Streams Integration",
            "description": "How do Lists integrate with Java 8 Streams?",
            "code": "List<String> words = Arrays.asList(\"hello\", \"world\", \"java\");\nList<String> upper = words.stream()\n    .map(String::toUpperCase)\n    .collect(Collectors.toList());",
            "options": [
                "Lists cannot use streams",
                "stream() method provides Stream interface",
                "Only ArrayList supports streams",
                "Requires conversion to array first"
            ],
            "correct": 1,
            "explanation": "All List implementations provide stream() method that returns a Stream, enabling functional-style operations on list elements."
        },
        {
            "id": 28,
            "title": "List.set() Method",
            "description": "What does the set() method do?",
            "code": "List<String> list = new ArrayList<>(Arrays.asList(\"A\", \"B\", \"C\"));\nString old = list.set(1, \"X\");\n// Result: [\"A\", \"X\", \"C\"], old = \"B\"",
            "options": [
                "Adds element at index",
                "Replaces element at index",
                "Inserts element at index",
                "Removes element at index"
            ],
            "correct": 1,
            "explanation": "set() replaces the element at the specified index and returns the previous element at that position."
        },
        {
            "id": 29,
            "title": "List Thread Safety",
            "description": "Which List implementations are thread-safe?",
            "code": "Vector<String> vector = new Vector<>();           // Thread-safe\nList<String> syncList = Collections.synchronizedList(new ArrayList<>()); // Thread-safe wrapper",
            "options": [
                "ArrayList only",
                "Vector and Collections.synchronizedList()",
                "LinkedList only",
                "None are thread-safe"
            ],
            "correct": 1,
            "explanation": "Vector is inherently thread-safe. Collections.synchronizedList() creates a thread-safe wrapper around any List implementation."
        },
        {
            "id": 30,
            "title": "List Best Practices",
            "description": "What is a best practice when working with Lists?",
            "code": "List<String> list = new ArrayList<>(); // Program to interface\n// vs\nArrayList<String> list = new ArrayList<>(); // Program to implementation",
            "options": [
                "Always use Vector for thread safety",
                "Program to interface (List) not implementation",
                "Use LinkedList for all operations",
                "Avoid generics for flexibility"
            ],
            "correct": 1,
            "explanation": "Best practice is to program to the interface (List) rather than implementation (ArrayList/LinkedList), providing flexibility to change implementations."
        }
    ]
}