{
    "id": 9,
    "name": "Java Collections Framework - Queue",
    "description": "Queue interface, PriorityQueue, ArrayDeque, LinkedList, BlockingQueue implementations, and queue operations in Java.",
    "proLocked": false,
    "isActive": true,
    "orderIndex": 8,
    "questions": [
        {
            "id": 1,
            "title": "Queue Interface Basics",
            "description": "What is the Queue interface in Java Collections Framework?",
            "code": "Queue<String> queue = new LinkedList<>();\nqueue.offer(\"First\");\nqueue.offer(\"Second\");\nString head = queue.poll(); // \"First\"\nSystem.out.println(queue.size()); // 1",
            "options": [
                "A LIFO (Last In, First Out) collection",
                "A FIFO (First In, First Out) collection",
                "A sorted collection",
                "A key-value pair collection"
            ],
            "correct": 1,
            "explanation": "Queue is a FIFO (First In, First Out) collection designed for holding elements prior to processing. Elements are added at the rear and removed from the front."
        },
        {
            "id": 2,
            "title": "Queue vs Deque",
            "description": "What is the difference between Queue and Deque interfaces?",
            "code": "Queue<String> queue = new LinkedList<>();\nqueue.offer(\"element\"); // Add to rear only\n\nDeque<String> deque = new ArrayDeque<>();\ndeque.offerFirst(\"first\");  // Add to front\ndeque.offerLast(\"last\");    // Add to rear",
            "options": [
                "No difference",
                "Deque allows insertion/removal at both ends",
                "Queue is thread-safe, Deque is not",
                "Deque is sorted, Queue is not"
            ],
            "correct": 1,
            "explanation": "Deque (Double Ended Queue) extends Queue and allows insertion and removal at both ends, while Queue only allows insertion at rear and removal from front."
        },
        {
            "id": 3,
            "title": "PriorityQueue Ordering",
            "description": "How does PriorityQueue order its elements?",
            "code": "PriorityQueue<Integer> pq = new PriorityQueue<>();\npq.offer(5);\npq.offer(1);\npq.offer(3);\nSystem.out.println(pq.poll()); // 1 (smallest first)",
            "options": [
                "FIFO order",
                "LIFO order",
                "Natural ordering or Comparator",
                "Insertion order"
            ],
            "correct": 2,
            "explanation": "PriorityQueue orders elements according to their natural ordering or by a Comparator provided at construction time. Smallest element has highest priority by default."
        },
        {
            "id": 4,
            "title": "Queue offer() vs add()",
            "description": "What is the difference between offer() and add() methods in Queue?",
            "code": "Queue<String> queue = new ArrayDeque<>();\nboolean result1 = queue.offer(\"element\"); // Returns false if fails\nboolean result2 = queue.add(\"element\");   // Throws exception if fails",
            "options": [
                "No difference",
                "offer() throws exception, add() returns false",
                "add() throws exception, offer() returns false",
                "offer() is faster than add()"
            ],
            "correct": 2,
            "explanation": "add() throws an exception if it fails to insert, while offer() returns false. In unbounded queues, they behave the same, but bounded queues show the difference."
        },
        {
            "id": 5,
            "title": "Queue poll() vs remove()",
            "description": "What is the difference between poll() and remove() methods in Queue?",
            "code": "Queue<String> queue = new LinkedList<>();\n// Empty queue\nString result1 = queue.poll();   // Returns null\nString result2 = queue.remove(); // Throws NoSuchElementException",
            "options": [
                "No difference",
                "poll() throws exception, remove() returns null",
                "remove() throws exception, poll() returns null",
                "poll() is faster than remove()"
            ],
            "correct": 2,
            "explanation": "remove() throws NoSuchElementException if queue is empty, while poll() returns null. Both remove and return the head element when queue is not empty."
        },
        {
            "id": 6,
            "title": "Queue peek() vs element()",
            "description": "What is the difference between peek() and element() methods in Queue?",
            "code": "Queue<String> queue = new LinkedList<>();\n// Empty queue\nString result1 = queue.peek();    // Returns null\nString result2 = queue.element(); // Throws NoSuchElementException",
            "options": [
                "No difference",
                "peek() throws exception, element() returns null",
                "element() throws exception, peek() returns null",
                "peek() removes element, element() doesn't"
            ],
            "correct": 2,
            "explanation": "element() throws NoSuchElementException if queue is empty, while peek() returns null. Both retrieve but do not remove the head element."
        },
        {
            "id": 7,
            "title": "ArrayDeque vs LinkedList",
            "description": "What are the performance differences between ArrayDeque and LinkedList as Queue implementations?",
            "code": "Queue<String> arrayDeque = new ArrayDeque<>();  // Resizable array\nQueue<String> linkedList = new LinkedList<>();  // Doubly-linked list",
            "options": [
                "LinkedList is always faster",
                "ArrayDeque is always faster",
                "ArrayDeque is faster for most operations",
                "Performance is identical"
            ],
            "correct": 2,
            "explanation": "ArrayDeque is generally faster than LinkedList for queue operations because it uses a resizable array with better cache locality and less memory overhead per element."
        },
        {
            "id": 8,
            "title": "PriorityQueue Null Values",
            "description": "Does PriorityQueue allow null values?",
            "code": "PriorityQueue<String> pq = new PriorityQueue<>();\n// pq.offer(null); // Throws NullPointerException",
            "options": [
                "Yes, null values are allowed",
                "No, null values throw NullPointerException",
                "Only one null value is allowed",
                "Depends on the Comparator"
            ],
            "correct": 1,
            "explanation": "PriorityQueue does not allow null values because it needs to compare elements for ordering, and null cannot be compared with other elements."
        },
        {
            "id": 9,
            "title": "Queue Iteration Order",
            "description": "What is the iteration order for different Queue implementations?",
            "code": "Queue<Integer> linkedList = new LinkedList<>(Arrays.asList(1, 2, 3));\nQueue<Integer> priorityQueue = new PriorityQueue<>(Arrays.asList(3, 1, 2));\n// LinkedList: 1, 2, 3 (insertion order)\n// PriorityQueue: not guaranteed to be sorted during iteration",
            "options": [
                "All queues iterate in FIFO order",
                "Iteration order depends on implementation",
                "All queues iterate in sorted order",
                "Iteration order is random"
            ],
            "correct": 1,
            "explanation": "Iteration order depends on implementation. LinkedList maintains insertion order, but PriorityQueue iteration is not guaranteed to be in priority order."
        },
        {
            "id": 10,
            "title": "BlockingQueue Interface",
            "description": "What is the purpose of BlockingQueue interface?",
            "code": "BlockingQueue<String> queue = new ArrayBlockingQueue<>(10);\nqueue.put(\"element\");    // Blocks if queue is full\nString item = queue.take(); // Blocks if queue is empty",
            "options": [
                "Prevents concurrent access",
                "Blocks threads when queue is full or empty",
                "Only allows one thread access",
                "Automatically sorts elements"
            ],
            "correct": 1,
            "explanation": "BlockingQueue extends Queue and provides blocking operations: put() blocks when full, take() blocks when empty. Used for producer-consumer scenarios."
        },
        {
            "id": 11,
            "title": "ArrayBlockingQueue vs LinkedBlockingQueue",
            "description": "What is the main difference between ArrayBlockingQueue and LinkedBlockingQueue?",
            "code": "BlockingQueue<String> arrayBQ = new ArrayBlockingQueue<>(100);  // Fixed capacity\nBlockingQueue<String> linkedBQ = new LinkedBlockingQueue<>();   // Unbounded (Integer.MAX_VALUE)",
            "options": [
                "No difference",
                "ArrayBlockingQueue is bounded, LinkedBlockingQueue can be unbounded",
                "LinkedBlockingQueue is faster",
                "ArrayBlockingQueue allows null values"
            ],
            "correct": 1,
            "explanation": "ArrayBlockingQueue has a fixed capacity set at construction time, while LinkedBlockingQueue can be unbounded (default) or bounded with optional capacity."
        },
        {
            "id": 12,
            "title": "PriorityQueue Custom Comparator",
            "description": "How do you create a PriorityQueue with custom ordering?",
            "code": "PriorityQueue<String> pq = new PriorityQueue<>(Collections.reverseOrder());\n// or\nPriorityQueue<String> pq2 = new PriorityQueue<>((a, b) -> b.compareTo(a));",
            "options": [
                "Override equals() method",
                "Use Comparator in constructor",
                "Use Collections.sort()",
                "Cannot customize PriorityQueue ordering"
            ],
            "correct": 1,
            "explanation": "Pass a Comparator to PriorityQueue constructor to define custom ordering. Elements must be comparable or a Comparator must be provided."
        },
        {
            "id": 13,
            "title": "Queue Size and Capacity",
            "description": "What is the difference between size() and capacity in Queue implementations?",
            "code": "ArrayBlockingQueue<String> queue = new ArrayBlockingQueue<>(10);\nqueue.offer(\"element\");\nint size = queue.size();           // 1 (current elements)\nint remainingCapacity = queue.remainingCapacity(); // 9",
            "options": [
                "No difference",
                "size() is current elements, capacity is maximum elements",
                "capacity() is current elements, size() is maximum",
                "Both return the same value"
            ],
            "correct": 1,
            "explanation": "size() returns the current number of elements, while capacity (or remainingCapacity()) relates to the maximum number of elements the queue can hold."
        },
        {
            "id": 14,
            "title": "DelayQueue Functionality",
            "description": "What is DelayQueue and when are elements available for retrieval?",
            "code": "DelayQueue<DelayedElement> delayQueue = new DelayQueue<>();\n// Elements only available after their delay expires\n// Implements Delayed interface with getDelay() method",
            "options": [
                "Elements available immediately",
                "Elements available after specified delay",
                "Elements sorted by insertion time",
                "Elements available in random order"
            ],
            "correct": 1,
            "explanation": "DelayQueue is a specialized BlockingQueue where elements can only be taken when their delay has expired. Elements must implement the Delayed interface."
        },
        {
            "id": 15,
            "title": "Queue Thread Safety",
            "description": "Which Queue implementations are thread-safe?",
            "code": "Queue<String> linkedList = new LinkedList<>();        // Not thread-safe\nQueue<String> concurrentLinkedQueue = new ConcurrentLinkedQueue<>(); // Thread-safe\nBlockingQueue<String> arrayBlockingQueue = new ArrayBlockingQueue<>(10); // Thread-safe",
            "options": [
                "All Queue implementations",
                "Only BlockingQueue implementations",
                "ConcurrentLinkedQueue and BlockingQueue implementations",
                "None are thread-safe"
            ],
            "correct": 2,
            "explanation": "ConcurrentLinkedQueue and all BlockingQueue implementations (ArrayBlockingQueue, LinkedBlockingQueue, etc.) are thread-safe. LinkedList and ArrayDeque are not."
        },
        {
            "id": 16,
            "title": "PriorityQueue Performance",
            "description": "What is the time complexity for offer() and poll() operations in PriorityQueue?",
            "code": "PriorityQueue<Integer> pq = new PriorityQueue<>();\npq.offer(5);  // O(log n) - heap insertion\nInteger min = pq.poll(); // O(log n) - heap extraction",
            "options": [
                "O(1)",
                "O(log n)",
                "O(n)",
                "O(nÂ²)"
            ],
            "correct": 1,
            "explanation": "PriorityQueue uses a binary heap, so offer() and poll() operations have O(log n) time complexity due to heap restructuring."
        },
        {
            "id": 17,
            "title": "Queue Bulk Operations",
            "description": "Which methods perform bulk operations on Queues?",
            "code": "Queue<String> queue = new LinkedList<>();\nCollection<String> items = Arrays.asList(\"A\", \"B\", \"C\");\nqueue.addAll(items);  // Bulk add\nqueue.removeAll(items); // Bulk remove",
            "options": [
                "addAll(), removeAll(), retainAll()",
                "offerAll(), pollAll()",
                "putAll(), takeAll()",
                "insertAll(), extractAll()"
            ],
            "correct": 0,
            "explanation": "Queue inherits bulk operations from Collection: addAll() for bulk insertion, removeAll() for bulk removal, and retainAll() for bulk retention."
        },
        {
            "id": 18,
            "title": "SynchronousQueue Characteristics",
            "description": "What is unique about SynchronousQueue?",
            "code": "SynchronousQueue<String> syncQueue = new SynchronousQueue<>();\n// No internal capacity - each put() must wait for take()\n// Direct handoff between producer and consumer threads",
            "options": [
                "Has unlimited capacity",
                "Has zero capacity - direct handoff",
                "Automatically sorts elements",
                "Allows duplicate elements"
            ],
            "correct": 1,
            "explanation": "SynchronousQueue has no internal capacity. Each put() operation must wait for a corresponding take() operation, creating direct handoff between threads."
        },
        {
            "id": 19,
            "title": "Queue Conversion to Array",
            "description": "How do you convert a Queue to an array?",
            "code": "Queue<String> queue = new LinkedList<>(Arrays.asList(\"A\", \"B\", \"C\"));\nString[] array = queue.toArray(new String[0]);",
            "options": [
                "queue.toArray()",
                "queue.toArray(new String[0])",
                "queue.toArray(new String[queue.size()])",
                "Both B and C"
            ],
            "correct": 3,
            "explanation": "Both toArray(new String[0]) and toArray(new String[queue.size()]) work correctly for converting Queue to array, inheriting from Collection interface."
        },
        {
            "id": 20,
            "title": "PriorityBlockingQueue Features",
            "description": "What are the characteristics of PriorityBlockingQueue?",
            "code": "PriorityBlockingQueue<Integer> pbq = new PriorityBlockingQueue<>();\n// Unbounded, thread-safe, priority-ordered\n// take() blocks when empty, put() never blocks",
            "options": [
                "Bounded and thread-safe",
                "Unbounded, thread-safe, and priority-ordered",
                "FIFO and thread-safe",
                "Fixed capacity with priorities"
            ],
            "correct": 1,
            "explanation": "PriorityBlockingQueue is an unbounded, thread-safe queue that orders elements by priority. take() blocks when empty, but put() never blocks due to unbounded nature."
        },
        {
            "id": 21,
            "title": "Queue Clear Operation",
            "description": "What does the clear() method do in Queue implementations?",
            "code": "Queue<String> queue = new LinkedList<>(Arrays.asList(\"A\", \"B\", \"C\"));\nqueue.clear();\nSystem.out.println(queue.size()); // 0",
            "options": [
                "Removes only the head element",
                "Removes all elements",
                "Sorts all elements",
                "Reverses element order"
            ],
            "correct": 1,
            "explanation": "clear() method removes all elements from the queue, making it empty. This is inherited from the Collection interface."
        },
        {
            "id": 22,
            "title": "LinkedTransferQueue Capabilities",
            "description": "What additional capability does LinkedTransferQueue provide?",
            "code": "LinkedTransferQueue<String> ltq = new LinkedTransferQueue<>();\nltq.transfer(\"element\"); // Waits until element is consumed\n// or\nboolean transferred = ltq.tryTransfer(\"element\"); // Non-blocking attempt",
            "options": [
                "Only basic queue operations",
                "Direct transfer to waiting consumers",
                "Automatic element sorting",
                "Fixed capacity management"
            ],
            "correct": 1,
            "explanation": "LinkedTransferQueue implements TransferQueue interface, allowing producers to wait for consumers via transfer() method or attempt non-blocking transfer with tryTransfer()."
        },
        {
            "id": 23,
            "title": "Queue Memory Efficiency",
            "description": "Which Queue implementation is most memory efficient?",
            "code": "// ArrayDeque: Resizable array, good cache locality\n// LinkedList: Node objects with pointers, more memory overhead\n// PriorityQueue: Array-based heap structure",
            "options": [
                "LinkedList",
                "ArrayDeque",
                "PriorityQueue",
                "All use same memory"
            ],
            "correct": 1,
            "explanation": "ArrayDeque is generally most memory efficient as it uses a resizable array without node objects, providing better cache locality and less memory overhead per element."
        },
        {
            "id": 24,
            "title": "Queue Contains Operation",
            "description": "What is the time complexity of contains() method in different Queue implementations?",
            "code": "Queue<String> arrayDeque = new ArrayDeque<>();     // O(n) linear search\nQueue<String> linkedList = new LinkedList<>();     // O(n) linear search\nPriorityQueue<String> priorityQueue = new PriorityQueue<>(); // O(n) linear search",
            "options": [
                "O(1) for all implementations",
                "O(log n) for all implementations",
                "O(n) for all implementations",
                "Varies by implementation"
            ],
            "correct": 2,
            "explanation": "contains() method has O(n) time complexity for all standard Queue implementations as it requires linear search through elements."
        },
        {
            "id": 25,
            "title": "Queue Stream Operations",
            "description": "How do Queues integrate with Java 8 Streams?",
            "code": "Queue<String> queue = new LinkedList<>(Arrays.asList(\"hello\", \"world\", \"java\"));\nList<String> upper = queue.stream()\n    .map(String::toUpperCase)\n    .collect(Collectors.toList());",
            "options": [
                "Queues cannot use streams",
                "stream() method provides Stream interface",
                "Only LinkedList supports streams",
                "Requires conversion to List first"
            ],
            "correct": 1,
            "explanation": "All Queue implementations provide stream() method inherited from Collection, enabling functional-style operations and easy collection transformations."
        },
        {
            "id": 26,
            "title": "Queue Equality Comparison",
            "description": "How are Queues compared for equality?",
            "code": "Queue<String> queue1 = new LinkedList<>(Arrays.asList(\"A\", \"B\", \"C\"));\nQueue<String> queue2 = new ArrayDeque<>(Arrays.asList(\"A\", \"B\", \"C\"));\nboolean equal = queue1.equals(queue2); // true - same elements, same order",
            "options": [
                "Same reference only",
                "Same elements in same order",
                "Same implementation type only",
                "Cannot compare different implementations"
            ],
            "correct": 1,
            "explanation": "Queues are equal if they contain the same elements in the same order, regardless of implementation type. Equality is based on element sequence."
        },
        {
            "id": 27,
            "title": "Queue Timeout Operations",
            "description": "Which Queue methods support timeout operations?",
            "code": "BlockingQueue<String> queue = new ArrayBlockingQueue<>(10);\nboolean offered = queue.offer(\"element\", 1, TimeUnit.SECONDS);\nString polled = queue.poll(1, TimeUnit.SECONDS);",
            "options": [
                "All Queue implementations",
                "Only BlockingQueue implementations",
                "Only PriorityQueue",
                "No Queue supports timeouts"
            ],
            "correct": 1,
            "explanation": "Only BlockingQueue implementations support timeout operations with offer(element, time, unit) and poll(time, unit) methods for timed blocking."
        },
        {
            "id": 28,
            "title": "Queue Best Practices",
            "description": "What is a best practice when working with Queues?",
            "code": "Queue<String> queue = new ArrayDeque<>(); // Program to interface\n// vs\nArrayDeque<String> queue = new ArrayDeque<>(); // Program to implementation",
            "options": [
                "Always use LinkedList",
                "Program to interface (Queue) not implementation",
                "Use PriorityQueue for all cases",
                "Avoid generics for flexibility"
            ],
            "correct": 1,
            "explanation": "Best practice is to program to the interface (Queue/Deque/BlockingQueue) rather than implementation, providing flexibility to change implementations based on requirements."
        },
        {
            "id": 29,
            "title": "Queue Exception Handling",
            "description": "Which Queue methods throw exceptions vs return special values?",
            "code": "Queue<String> queue = new ArrayDeque<>();\n// Exception methods: add(), remove(), element()\n// Special value methods: offer(), poll(), peek()",
            "options": [
                "All methods throw exceptions",
                "All methods return special values",
                "Some throw exceptions, some return special values",
                "Behavior depends on queue size"
            ],
            "correct": 2,
            "explanation": "Queue provides two sets of methods: add()/remove()/element() throw exceptions on failure, while offer()/poll()/peek() return special values (false/null)."
        },
        {
            "id": 30,
            "title": "Queue Implementation Selection",
            "description": "When should you choose different Queue implementations?",
            "code": "// ArrayDeque: General purpose, best performance\n// LinkedList: When you need List operations too\n// PriorityQueue: When you need priority ordering\n// BlockingQueue: For producer-consumer scenarios",
            "options": [
                "Always use LinkedList",
                "Choose based on specific requirements",
                "PriorityQueue for all cases",
                "Implementation doesn't matter"
            ],
            "correct": 1,
            "explanation": "Choose implementation based on requirements: ArrayDeque for general use, PriorityQueue for priority ordering, BlockingQueue for thread coordination, LinkedList when you need List operations."
        }
    ]
}