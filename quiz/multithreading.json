[
    {
        "title": "ThreadCreation - Q0001",
        "text": "Which of the following is NOT a valid way to create a thread in Java",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Extending the Thread class"
            },
            {
                "letter": "B",
                "text": "Implementing the Runnable interface"
            },
            {
                "letter": "C",
                "text": "Using the Executor framework"
            },
            {
                "letter": "D",
                "text": "Using the 'thread' keyword"
            }
        ],
        "correct": "D",
        "explanation": "There is no 'thread' keyword in Java."
    },
    {
        "title": "ThreadCreation - Q0002",
        "text": "Which method is used to start a thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "run()"
            },
            {
                "letter": "B",
                "text": "start()"
            },
            {
                "letter": "C",
                "text": "execute()"
            },
            {
                "letter": "D",
                "text": "init()"
            }
        ],
        "correct": "B",
        "explanation": "The start() method is used to start a new thread."
    },
    {
        "title": "ThreadCreation - Q0003",
        "text": "What happens if run() is called directly instead of start()",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "A new thread is created"
            },
            {
                "letter": "B",
                "text": "The code runs in the current thread"
            },
            {
                "letter": "C",
                "text": "Compilation error"
            },
            {
                "letter": "D",
                "text": "Runtime exception"
            }
        ],
        "correct": "B",
        "explanation": "Calling run() directly executes the code in the current thread."
    },
    {
        "title": "ThreadCreation - Q0004",
        "text": "Which of the following is true about extending the Thread class",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "The class must override the run() method"
            },
            {
                "letter": "B",
                "text": "The class must override the start() method"
            },
            {
                "letter": "C",
                "text": "The class must override the sleep() method"
            },
            {
                "letter": "D",
                "text": "The class must override the yield() method"
            }
        ],
        "correct": "A",
        "explanation": "When extending Thread, the run() method should be overridden."
    },
    {
        "title": "ThreadCreation - Q0005",
        "text": "Which interface must be implemented to create a thread without extending Thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Runnable"
            },
            {
                "letter": "B",
                "text": "Callable"
            },
            {
                "letter": "C",
                "text": "Executor"
            },
            {
                "letter": "D",
                "text": "Threadable"
            }
        ],
        "correct": "A",
        "explanation": "Runnable is the interface used to create threads without extending Thread."
    },
    {
        "title": "ThreadCreation - Q0006",
        "text": "Which method must be implemented when using the Runnable interface",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "start()"
            },
            {
                "letter": "B",
                "text": "run()"
            },
            {
                "letter": "C",
                "text": "execute()"
            },
            {
                "letter": "D",
                "text": "init()"
            }
        ],
        "correct": "B",
        "explanation": "The run() method must be implemented in Runnable."
    },
    {
        "title": "ThreadCreation - Q0007",
        "text": "Which of the following is true about the start() method",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "It creates a new thread and calls run()"
            },
            {
                "letter": "B",
                "text": "It directly executes run() in the current thread"
            },
            {
                "letter": "C",
                "text": "It must be overridden"
            },
            {
                "letter": "D",
                "text": "It is abstract"
            }
        ],
        "correct": "A",
        "explanation": "start() creates a new thread and then calls run()."
    },
    {
        "title": "ThreadCreation - Q0008",
        "text": "Which of the following is NOT a valid constructor of the Thread class",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Thread()"
            },
            {
                "letter": "B",
                "text": "Thread(Runnable target)"
            },
            {
                "letter": "C",
                "text": "Thread(String name)"
            },
            {
                "letter": "D",
                "text": "Thread(int priority)"
            }
        ],
        "correct": "D",
        "explanation": "There is no Thread constructor that takes only an int priority."
    },
    {
        "title": "ThreadCreation - Q0009",
        "text": "Which of the following is true about creating a thread using Runnable",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Runnable must override start()"
            },
            {
                "letter": "B",
                "text": "Runnable must override run()"
            },
            {
                "letter": "C",
                "text": "Runnable must override sleep()"
            },
            {
                "letter": "D",
                "text": "Runnable must override yield()"
            }
        ],
        "correct": "B",
        "explanation": "Runnable requires implementing the run() method."
    },
    {
        "title": "ThreadCreation - Q0010",
        "text": "Which of the following is true about Callable compared to Runnable",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Callable returns a value"
            },
            {
                "letter": "B",
                "text": "Callable cannot throw exceptions"
            },
            {
                "letter": "C",
                "text": "Callable has a run() method"
            },
            {
                "letter": "D",
                "text": "Callable is used only with Thread"
            }
        ],
        "correct": "A",
        "explanation": "Callable's call() method returns a value and can throw exceptions."
    },
    {
        "title": "ThreadCreation - Q0011",
        "text": "Which method is defined in the Runnable interface",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "run()"
            },
            {
                "letter": "B",
                "text": "start()"
            },
            {
                "letter": "C",
                "text": "execute()"
            },
            {
                "letter": "D",
                "text": "call()"
            }
        ],
        "correct": "A",
        "explanation": "Runnable defines the run() method."
    },
    {
        "title": "ThreadCreation - Q0012",
        "text": "Which method is defined in the Callable interface",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "run()"
            },
            {
                "letter": "B",
                "text": "start()"
            },
            {
                "letter": "C",
                "text": "call()"
            },
            {
                "letter": "D",
                "text": "execute()"
            }
        ],
        "correct": "C",
        "explanation": "Callable defines the call() method."
    },
    {
        "title": "ThreadCreation - Q0013",
        "text": "Which of the following is true about creating a thread by extending Thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "The class must implement call()"
            },
            {
                "letter": "B",
                "text": "The class must override run()"
            },
            {
                "letter": "C",
                "text": "The class must override start()"
            },
            {
                "letter": "D",
                "text": "The class must implement execute()"
            }
        ],
        "correct": "B",
        "explanation": "When extending Thread, override run() to define thread behavior."
    },
    {
        "title": "ThreadCreation - Q0014",
        "text": "Which of the following is true about the Executor framework",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "It provides a higher-level API for managing threads"
            },
            {
                "letter": "B",
                "text": "It replaces the Thread class"
            },
            {
                "letter": "C",
                "text": "It cannot execute Runnable tasks"
            },
            {
                "letter": "D",
                "text": "It is deprecated"
            }
        ],
        "correct": "A",
        "explanation": "The Executor framework provides a higher-level API for managing threads."
    },
    {
        "title": "ThreadCreation - Q0015",
        "text": "Which of the following is true about thread pools",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "They reuse threads for executing tasks"
            },
            {
                "letter": "B",
                "text": "They create a new thread for each task"
            },
            {
                "letter": "C",
                "text": "They cannot execute Runnable tasks"
            },
            {
                "letter": "D",
                "text": "They are deprecated"
            }
        ],
        "correct": "A",
        "explanation": "Thread pools reuse threads for executing multiple tasks."
    },
    {
        "title": "ThreadCreation - Q0016",
        "text": "Which of the following is true about Future in Java",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "It represents the result of an asynchronous computation"
            },
            {
                "letter": "B",
                "text": "It is used to create threads"
            },
            {
                "letter": "C",
                "text": "It is used to stop threads"
            },
            {
                "letter": "D",
                "text": "It is used to pause threads"
            }
        ],
        "correct": "A",
        "explanation": "Future represents the result of an asynchronous computation."
    },
    {
        "title": "ThreadCreation - Q0017",
        "text": "Which of the following is true about Executors.newFixedThreadPool()",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "It creates a thread pool with a fixed number of threads"
            },
            {
                "letter": "B",
                "text": "It creates a new thread for each task"
            },
            {
                "letter": "C",
                "text": "It creates a thread pool with unlimited threads"
            },
            {
                "letter": "D",
                "text": "It creates a single-threaded executor"
            }
        ],
        "correct": "A",
        "explanation": "newFixedThreadPool() creates a pool with a fixed number of threads."
    },
    {
        "title": "ThreadCreation - Q0018",
        "text": "Which of the following is true about Executors.newSingleThreadExecutor()",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "It creates a thread pool with one thread"
            },
            {
                "letter": "B",
                "text": "It creates a thread pool with unlimited threads"
            },
            {
                "letter": "C",
                "text": "It creates a thread pool with a fixed number of threads"
            },
            {
                "letter": "D",
                "text": "It creates a cached thread pool"
            }
        ],
        "correct": "A",
        "explanation": "newSingleThreadExecutor() creates a pool with one thread."
    },
    {
        "title": "ThreadCreation - Q0019",
        "text": "Which of the following is true about Executors.newCachedThreadPool()",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "It creates a thread pool that creates new threads as needed"
            },
            {
                "letter": "B",
                "text": "It creates a thread pool with one thread"
            },
            {
                "letter": "C",
                "text": "It creates a thread pool with a fixed number of threads"
            },
            {
                "letter": "D",
                "text": "It creates a scheduled thread pool"
            }
        ],
        "correct": "A",
        "explanation": "newCachedThreadPool() creates new threads as needed and reuses idle ones."
    },
    {
        "title": "ThreadCreation - Q0020",
        "text": "Which of the following is true about Executors.newScheduledThreadPool()",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "It creates a thread pool that can schedule tasks"
            },
            {
                "letter": "B",
                "text": "It creates a thread pool with one thread"
            },
            {
                "letter": "C",
                "text": "It creates a thread pool with unlimited threads"
            },
            {
                "letter": "D",
                "text": "It creates a cached thread pool"
            }
        ],
        "correct": "A",
        "explanation": "newScheduledThreadPool() creates a pool that can schedule tasks."
    },
    {
        "title": "ThreadCreation - Q0021",
        "text": "Which of the following is true about the run() method in a thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "It must be called directly to start a thread"
            },
            {
                "letter": "B",
                "text": "It contains the code executed by the thread"
            },
            {
                "letter": "C",
                "text": "It is automatically called by the JVM when the program starts"
            },
            {
                "letter": "D",
                "text": "It cannot be overridden"
            }
        ],
        "correct": "B",
        "explanation": "The run() method contains the code executed by the thread."
    },
    {
        "title": "ThreadCreation - Q0022",
        "text": "Which of the following is true about the start() method",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "It can be called multiple times on the same thread"
            },
            {
                "letter": "B",
                "text": "It can only be called once per thread instance"
            },
            {
                "letter": "C",
                "text": "It is optional for starting a thread"
            },
            {
                "letter": "D",
                "text": "It is abstract and must be implemented"
            }
        ],
        "correct": "B",
        "explanation": "start() can only be called once per thread instance."
    },
    {
        "title": "ThreadCreation - Q0023",
        "text": "What happens if start() is called twice on the same thread object",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "The thread runs twice"
            },
            {
                "letter": "B",
                "text": "A new thread is created"
            },
            {
                "letter": "C",
                "text": "IllegalThreadStateException is thrown"
            },
            {
                "letter": "D",
                "text": "Nothing happens"
            }
        ],
        "correct": "C",
        "explanation": "Calling start() twice throws IllegalThreadStateException."
    },
    {
        "title": "ThreadCreation - Q0024",
        "text": "Which of the following is true about thread naming",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Threads cannot be named"
            },
            {
                "letter": "B",
                "text": "Threads can be named using the constructor or setName()"
            },
            {
                "letter": "C",
                "text": "Thread names are fixed by the JVM"
            },
            {
                "letter": "D",
                "text": "Thread names must be unique"
            }
        ],
        "correct": "B",
        "explanation": "Threads can be named using the constructor or setName()."
    },
    {
        "title": "ThreadCreation - Q0025",
        "text": "Which method retrieves the current thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Thread.current()"
            },
            {
                "letter": "B",
                "text": "Thread.get()"
            },
            {
                "letter": "C",
                "text": "Thread.currentThread()"
            },
            {
                "letter": "D",
                "text": "Thread.this()"
            }
        ],
        "correct": "C",
        "explanation": "Thread.currentThread() returns the current thread."
    },
    {
        "title": "ThreadCreation - Q0026",
        "text": "Which of the following is true about thread priority",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Thread priority ranges from 0 to 10"
            },
            {
                "letter": "B",
                "text": "Thread priority ranges from 1 to 10"
            },
            {
                "letter": "C",
                "text": "Thread priority ranges from -1 to 1"
            },
            {
                "letter": "D",
                "text": "Thread priority cannot be changed"
            }
        ],
        "correct": "B",
        "explanation": "Thread priority ranges from 1 (MIN_PRIORITY) to 10 (MAX_PRIORITY)."
    },
    {
        "title": "ThreadCreation - Q0027",
        "text": "Which method is used to set thread priority",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "setPriority()"
            },
            {
                "letter": "B",
                "text": "priority()"
            },
            {
                "letter": "C",
                "text": "setLevel()"
            },
            {
                "letter": "D",
                "text": "setImportance()"
            }
        ],
        "correct": "A",
        "explanation": "setPriority() is used to set thread priority."
    },
    {
        "title": "ThreadCreation - Q0028",
        "text": "Which method is used to get the name of a thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "getThreadName()"
            },
            {
                "letter": "B",
                "text": "getName()"
            },
            {
                "letter": "C",
                "text": "name()"
            },
            {
                "letter": "D",
                "text": "threadName()"
            }
        ],
        "correct": "B",
        "explanation": "getName() returns the name of the thread."
    },
    {
        "title": "ThreadCreation - Q0029",
        "text": "Which method is used to set the name of a thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "setThreadName()"
            },
            {
                "letter": "B",
                "text": "setName()"
            },
            {
                "letter": "C",
                "text": "name()"
            },
            {
                "letter": "D",
                "text": "threadName()"
            }
        ],
        "correct": "B",
        "explanation": "setName() sets the name of the thread."
    },
    {
        "title": "ThreadCreation - Q0030",
        "text": "Which of the following is true about daemon threads",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "They prevent the JVM from exiting"
            },
            {
                "letter": "B",
                "text": "They run in the background and do not prevent JVM exit"
            },
            {
                "letter": "C",
                "text": "They are created by default"
            },
            {
                "letter": "D",
                "text": "They cannot be created by the user"
            }
        ],
        "correct": "B",
        "explanation": "Daemon threads run in the background and do not prevent JVM exit."
    },
    {
        "title": "ThreadCreation - Q0031",
        "text": "Which method is used to mark a thread as daemon",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "setDaemon()"
            },
            {
                "letter": "B",
                "text": "daemon()"
            },
            {
                "letter": "C",
                "text": "makeDaemon()"
            },
            {
                "letter": "D",
                "text": "setBackground()"
            }
        ],
        "correct": "A",
        "explanation": "setDaemon(true) marks a thread as daemon."
    },
    {
        "title": "ThreadCreation - Q0032",
        "text": "Which method checks if a thread is a daemon",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "isDaemon()"
            },
            {
                "letter": "B",
                "text": "checkDaemon()"
            },
            {
                "letter": "C",
                "text": "daemon()"
            },
            {
                "letter": "D",
                "text": "isBackground()"
            }
        ],
        "correct": "A",
        "explanation": "isDaemon() checks if a thread is a daemon."
    },
    {
        "title": "ThreadCreation - Q0033",
        "text": "Which of the following is true about thread groups",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "They allow grouping of multiple threads"
            },
            {
                "letter": "B",
                "text": "They prevent thread creation"
            },
            {
                "letter": "C",
                "text": "They are mandatory for all threads"
            },
            {
                "letter": "D",
                "text": "They are deprecated"
            }
        ],
        "correct": "A",
        "explanation": "Thread groups allow grouping of multiple threads."
    },
    {
        "title": "ThreadCreation - Q0034",
        "text": "Which constructor allows assigning a thread to a thread group",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Thread(ThreadGroup group, Runnable target)"
            },
            {
                "letter": "B",
                "text": "Thread(Runnable target, int priority)"
            },
            {
                "letter": "C",
                "text": "Thread(String name, int priority)"
            },
            {
                "letter": "D",
                "text": "Thread(ThreadGroup group, int priority)"
            }
        ],
        "correct": "A",
        "explanation": "Thread(ThreadGroup group, Runnable target) assigns a thread to a group."
    },
    {
        "title": "ThreadCreation - Q0035",
        "text": "Which method returns the thread group of a thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "getThreadGroup()"
            },
            {
                "letter": "B",
                "text": "getGroup()"
            },
            {
                "letter": "C",
                "text": "group()"
            },
            {
                "letter": "D",
                "text": "threadGroup()"
            }
        ],
        "correct": "A",
        "explanation": "getThreadGroup() returns the thread group of a thread."
    },
    {
        "title": "ThreadCreation - Q0036",
        "text": "Which of the following is true about thread states",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "A thread can only be in NEW or TERMINATED state"
            },
            {
                "letter": "B",
                "text": "A thread can be in NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, or TERMINATED"
            },
            {
                "letter": "C",
                "text": "A thread can only be RUNNING or STOPPED"
            },
            {
                "letter": "D",
                "text": "Thread states are not defined in Java"
            }
        ],
        "correct": "B",
        "explanation": "Java defines six thread states."
    },
    {
        "title": "ThreadCreation - Q0037",
        "text": "Which method returns the state of a thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "getState()"
            },
            {
                "letter": "B",
                "text": "state()"
            },
            {
                "letter": "C",
                "text": "threadState()"
            },
            {
                "letter": "D",
                "text": "status()"
            }
        ],
        "correct": "A",
        "explanation": "getState() returns the state of a thread."
    },
    {
        "title": "ThreadCreation - Q0038",
        "text": "Which of the following is true about the default thread priority",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "It is 0"
            },
            {
                "letter": "B",
                "text": "It is 1"
            },
            {
                "letter": "C",
                "text": "It is 5"
            },
            {
                "letter": "D",
                "text": "It is 10"
            }
        ],
        "correct": "C",
        "explanation": "The default thread priority is 5 (NORM_PRIORITY)."
    },
    {
        "title": "ThreadCreation - Q0039",
        "text": "Which of the following is true about creating threads using lambda expressions",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "It is not allowed"
            },
            {
                "letter": "B",
                "text": "It can be done by passing a lambda to the Thread constructor"
            },
            {
                "letter": "C",
                "text": "It requires implementing Callable"
            },
            {
                "letter": "D",
                "text": "It requires overriding start()"
            }
        ],
        "correct": "B",
        "explanation": "A lambda can be passed to the Thread constructor as a Runnable."
    },
    {
        "title": "ThreadCreation - Q0040",
        "text": "Which of the following is true about thread IDs",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "They are assigned manually"
            },
            {
                "letter": "B",
                "text": "They are assigned by the JVM"
            },
            {
                "letter": "C",
                "text": "They must be unique across JVMs"
            },
            {
                "letter": "D",
                "text": "They are always sequential"
            }
        ],
        "correct": "B",
        "explanation": "Thread IDs are assigned by the JVM."
    },
    {
        "title": "ThreadCreation - Q0041",
        "text": "Which method returns the ID of a thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "getThreadId()"
            },
            {
                "letter": "B",
                "text": "getId()"
            },
            {
                "letter": "C",
                "text": "id()"
            },
            {
                "letter": "D",
                "text": "threadId()"
            }
        ],
        "correct": "B",
        "explanation": "getId() returns the ID of a thread."
    },
    {
        "title": "ThreadCreation - Q0042",
        "text": "Which of the following is true about thread interruption",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "It forcibly stops the thread"
            },
            {
                "letter": "B",
                "text": "It sets the interrupt flag of the thread"
            },
            {
                "letter": "C",
                "text": "It deletes the thread"
            },
            {
                "letter": "D",
                "text": "It restarts the thread"
            }
        ],
        "correct": "B",
        "explanation": "interrupt() sets the interrupt flag of the thread."
    },
    {
        "title": "ThreadCreation - Q0043",
        "text": "Which method checks if a thread has been interrupted",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "isInterrupted()"
            },
            {
                "letter": "B",
                "text": "checkInterrupt()"
            },
            {
                "letter": "C",
                "text": "interrupted()"
            },
            {
                "letter": "D",
                "text": "hasInterrupted()"
            }
        ],
        "correct": "A",
        "explanation": "isInterrupted() checks if a thread has been interrupted."
    },
    {
        "title": "ThreadCreation - Q0044",
        "text": "Which static method clears the interrupt flag when checking it",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "isInterrupted()"
            },
            {
                "letter": "B",
                "text": "interrupted()"
            },
            {
                "letter": "C",
                "text": "checkInterrupt()"
            },
            {
                "letter": "D",
                "text": "clearInterrupt()"
            }
        ],
        "correct": "B",
        "explanation": "Thread.interrupted() checks and clears the interrupt flag."
    },
    {
        "title": "ThreadCreation - Q0045",
        "text": "Which of the following is true about thread lifecycle",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "A thread can be restarted after termination"
            },
            {
                "letter": "B",
                "text": "A thread cannot be restarted once terminated"
            },
            {
                "letter": "C",
                "text": "A thread can only be in NEW or RUNNING state"
            },
            {
                "letter": "D",
                "text": "Thread lifecycle is not defined in Java"
            }
        ],
        "correct": "B",
        "explanation": "A thread cannot be restarted once terminated."
    },
    {
        "title": "ThreadCreation - Q0046",
        "text": "Which of the following is true about creating threads with Callable",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Callable must be passed to a Thread constructor"
            },
            {
                "letter": "B",
                "text": "Callable must be submitted to an ExecutorService"
            },
            {
                "letter": "C",
                "text": "Callable must override run()"
            },
            {
                "letter": "D",
                "text": "Callable cannot return values"
            }
        ],
        "correct": "B",
        "explanation": "Callable tasks are submitted to an ExecutorService."
    },
    {
        "title": "ThreadCreation - Q0047",
        "text": "Which of the following is true about FutureTask",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "It is used to wrap a Callable or Runnable"
            },
            {
                "letter": "B",
                "text": "It is used to stop threads"
            },
            {
                "letter": "C",
                "text": "It is used to pause threads"
            },
            {
                "letter": "D",
                "text": "It is used to restart threads"
            }
        ],
        "correct": "A",
        "explanation": "FutureTask wraps a Callable or Runnable and can be executed by a thread."
    },
    {
        "title": "ThreadCreation - Q0048",
        "text": "Which of the following is true about ScheduledExecutorService",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "It can schedule tasks to run after a delay or periodically"
            },
            {
                "letter": "B",
                "text": "It can only run tasks immediately"
            },
            {
                "letter": "C",
                "text": "It cannot execute Runnable tasks"
            },
            {
                "letter": "D",
                "text": "It is deprecated"
            }
        ],
        "correct": "A",
        "explanation": "ScheduledExecutorService can schedule tasks with delay or periodically."
    },
    {
        "title": "ThreadCreation - Q0049",
        "text": "Which of the following is true about creating threads with anonymous classes",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "It is not allowed"
            },
            {
                "letter": "B",
                "text": "It can be done by creating an anonymous Runnable or Thread subclass"
            },
            {
                "letter": "C",
                "text": "It requires implementing Callable"
            },
            {
                "letter": "D",
                "text": "It requires overriding start()"
            }
        ],
        "correct": "B",
        "explanation": "Threads can be created using anonymous Runnable or Thread subclasses."
    },
    {
        "title": "ThreadCreation - Q0050",
        "text": "Which of the following is true about thread creation in Java",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Threads can only be created by extending Thread"
            },
            {
                "letter": "B",
                "text": "Threads can be created by extending Thread, implementing Runnable, or using Executor framework"
            },
            {
                "letter": "C",
                "text": "Threads can only be created using Executor framework"
            },
            {
                "letter": "D",
                "text": "Threads cannot be created by the user"
            }
        ],
        "correct": "B",
        "explanation": "Threads can be created by extending Thread, implementing Runnable, or using Executor framework."
    },
    {
        "title": "Lifecycle - Q0001",
        "text": "Which of the following is the first state of a thread in Java",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "RUNNABLE"
            },
            {
                "letter": "B",
                "text": "NEW"
            },
            {
                "letter": "C",
                "text": "WAITING"
            },
            {
                "letter": "D",
                "text": "TERMINATED"
            }
        ],
        "correct": "B",
        "explanation": "When a thread object is created, it is in the NEW state."
    },
    {
        "title": "Lifecycle - Q0002",
        "text": "Which method transitions a thread from NEW to RUNNABLE state",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "run()"
            },
            {
                "letter": "B",
                "text": "start()"
            },
            {
                "letter": "C",
                "text": "sleep()"
            },
            {
                "letter": "D",
                "text": "yield()"
            }
        ],
        "correct": "B",
        "explanation": "Calling start() moves a thread from NEW to RUNNABLE."
    },
    {
        "title": "Lifecycle - Q0003",
        "text": "Which state indicates that a thread is ready to run but waiting for CPU",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "RUNNABLE"
            },
            {
                "letter": "B",
                "text": "RUNNING"
            },
            {
                "letter": "C",
                "text": "WAITING"
            },
            {
                "letter": "D",
                "text": "BLOCKED"
            }
        ],
        "correct": "A",
        "explanation": "RUNNABLE means the thread is ready but waiting for CPU scheduling."
    },
    {
        "title": "Lifecycle - Q0004",
        "text": "Which state indicates that a thread is actively executing",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "RUNNABLE"
            },
            {
                "letter": "B",
                "text": "RUNNING"
            },
            {
                "letter": "C",
                "text": "WAITING"
            },
            {
                "letter": "D",
                "text": "NEW"
            }
        ],
        "correct": "B",
        "explanation": "RUNNING means the thread is actively executing instructions."
    },
    {
        "title": "Lifecycle - Q0005",
        "text": "Which state occurs when a thread is waiting indefinitely for another thread to signal",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "WAITING"
            },
            {
                "letter": "B",
                "text": "TIMED_WAITING"
            },
            {
                "letter": "C",
                "text": "BLOCKED"
            },
            {
                "letter": "D",
                "text": "TERMINATED"
            }
        ],
        "correct": "A",
        "explanation": "WAITING means the thread waits indefinitely until notified."
    },
    {
        "title": "Lifecycle - Q0006",
        "text": "Which state occurs when a thread waits for a specified time",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "WAITING"
            },
            {
                "letter": "B",
                "text": "TIMED_WAITING"
            },
            {
                "letter": "C",
                "text": "BLOCKED"
            },
            {
                "letter": "D",
                "text": "RUNNABLE"
            }
        ],
        "correct": "B",
        "explanation": "TIMED_WAITING means the thread waits for a specified time."
    },
    {
        "title": "Lifecycle - Q0007",
        "text": "Which state occurs when a thread is waiting to acquire a monitor lock",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "WAITING"
            },
            {
                "letter": "B",
                "text": "BLOCKED"
            },
            {
                "letter": "C",
                "text": "RUNNABLE"
            },
            {
                "letter": "D",
                "text": "TERMINATED"
            }
        ],
        "correct": "B",
        "explanation": "BLOCKED means the thread is waiting to acquire a monitor lock."
    },
    {
        "title": "Lifecycle - Q0008",
        "text": "Which state indicates that a thread has finished execution",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "WAITING"
            },
            {
                "letter": "B",
                "text": "RUNNABLE"
            },
            {
                "letter": "C",
                "text": "TERMINATED"
            },
            {
                "letter": "D",
                "text": "BLOCKED"
            }
        ],
        "correct": "C",
        "explanation": "TERMINATED means the thread has finished execution."
    },
    {
        "title": "Lifecycle - Q0009",
        "text": "Which method causes a thread to sleep for a given time",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "wait()"
            },
            {
                "letter": "B",
                "text": "sleep()"
            },
            {
                "letter": "C",
                "text": "yield()"
            },
            {
                "letter": "D",
                "text": "join()"
            }
        ],
        "correct": "B",
        "explanation": "sleep() pauses the thread for a specified time."
    },
    {
        "title": "Lifecycle - Q0010",
        "text": "Which method allows one thread to wait for another to finish",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "sleep()"
            },
            {
                "letter": "B",
                "text": "join()"
            },
            {
                "letter": "C",
                "text": "yield()"
            },
            {
                "letter": "D",
                "text": "notify()"
            }
        ],
        "correct": "B",
        "explanation": "join() makes one thread wait until another finishes."
    },
    {
        "title": "Lifecycle - Q0011",
        "text": "Which method is used to notify a waiting thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "notify()"
            },
            {
                "letter": "B",
                "text": "signal()"
            },
            {
                "letter": "C",
                "text": "wake()"
            },
            {
                "letter": "D",
                "text": "resume()"
            }
        ],
        "correct": "A",
        "explanation": "notify() wakes up one waiting thread."
    },
    {
        "title": "Lifecycle - Q0012",
        "text": "Which method wakes up all waiting threads",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "notify()"
            },
            {
                "letter": "B",
                "text": "notifyAll()"
            },
            {
                "letter": "C",
                "text": "wakeAll()"
            },
            {
                "letter": "D",
                "text": "resumeAll()"
            }
        ],
        "correct": "B",
        "explanation": "notifyAll() wakes up all waiting threads."
    },
    {
        "title": "Lifecycle - Q0013",
        "text": "Which method temporarily pauses the current thread and allows others to execute",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "sleep()"
            },
            {
                "letter": "B",
                "text": "yield()"
            },
            {
                "letter": "C",
                "text": "wait()"
            },
            {
                "letter": "D",
                "text": "join()"
            }
        ],
        "correct": "B",
        "explanation": "yield() hints the scheduler to pause the current thread."
    },
    {
        "title": "Lifecycle - Q0014",
        "text": "Which method is used to check if a thread is alive",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "isRunning()"
            },
            {
                "letter": "B",
                "text": "isAlive()"
            },
            {
                "letter": "C",
                "text": "alive()"
            },
            {
                "letter": "D",
                "text": "status()"
            }
        ],
        "correct": "B",
        "explanation": "isAlive() checks if a thread is still running."
    },
    {
        "title": "Lifecycle - Q0015",
        "text": "Which method is used to stop a thread safely",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "stop()"
            },
            {
                "letter": "B",
                "text": "destroy()"
            },
            {
                "letter": "C",
                "text": "interrupt()"
            },
            {
                "letter": "D",
                "text": "exit()"
            }
        ],
        "correct": "C",
        "explanation": "interrupt() is the safe way to request a thread to stop."
    },
    {
        "title": "Lifecycle - Q0016",
        "text": "Which state does a thread enter after calling sleep()",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "WAITING"
            },
            {
                "letter": "B",
                "text": "TIMED_WAITING"
            },
            {
                "letter": "C",
                "text": "BLOCKED"
            },
            {
                "letter": "D",
                "text": "TERMINATED"
            }
        ],
        "correct": "B",
        "explanation": "sleep() puts the thread into TIMED_WAITING."
    },
    {
        "title": "Lifecycle - Q0017",
        "text": "Which state does a thread enter after calling join()",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "WAITING or TIMED_WAITING"
            },
            {
                "letter": "B",
                "text": "BLOCKED"
            },
            {
                "letter": "C",
                "text": "RUNNABLE"
            },
            {
                "letter": "D",
                "text": "TERMINATED"
            }
        ],
        "correct": "A",
        "explanation": "join() puts the thread into WAITING or TIMED_WAITING depending on overload."
    },
    {
        "title": "Lifecycle - Q0018",
        "text": "Which state does a thread enter when waiting for a lock",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "WAITING"
            },
            {
                "letter": "B",
                "text": "BLOCKED"
            },
            {
                "letter": "C",
                "text": "RUNNABLE"
            },
            {
                "letter": "D",
                "text": "NEW"
            }
        ],
        "correct": "B",
        "explanation": "BLOCKED means waiting for a monitor lock."
    },
    {
        "title": "Lifecycle - Q0019",
        "text": "Which state does a thread enter after finishing execution",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "RUNNABLE"
            },
            {
                "letter": "B",
                "text": "WAITING"
            },
            {
                "letter": "C",
                "text": "TERMINATED"
            },
            {
                "letter": "D",
                "text": "BLOCKED"
            }
        ],
        "correct": "C",
        "explanation": "TERMINATED means the thread has finished execution."
    },
    {
        "title": "Lifecycle - Q0020",
        "text": "Which method is used to get the current state of a thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "getState()"
            },
            {
                "letter": "B",
                "text": "state()"
            },
            {
                "letter": "C",
                "text": "status()"
            },
            {
                "letter": "D",
                "text": "threadState()"
            }
        ],
        "correct": "A",
        "explanation": "getState() returns the current state of a thread."
    },
    {
        "title": "Lifecycle - Q0021",
        "text": "Which of the following is NOT a valid thread state in Java",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "NEW"
            },
            {
                "letter": "B",
                "text": "RUNNABLE"
            },
            {
                "letter": "C",
                "text": "SUSPENDED"
            },
            {
                "letter": "D",
                "text": "TERMINATED"
            }
        ],
        "correct": "C",
        "explanation": "SUSPENDED is not a valid state in modern Java; it was deprecated long ago."
    },
    {
        "title": "Lifecycle - Q0022",
        "text": "Which method is used to voluntarily give up CPU control",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "yield()"
            },
            {
                "letter": "B",
                "text": "sleep()"
            },
            {
                "letter": "C",
                "text": "wait()"
            },
            {
                "letter": "D",
                "text": "pause()"
            }
        ],
        "correct": "A",
        "explanation": "yield() hints the scheduler to give other threads a chance to run."
    },
    {
        "title": "Lifecycle - Q0023",
        "text": "Which method is used to pause a thread until another thread completes",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "join()"
            },
            {
                "letter": "B",
                "text": "sleep()"
            },
            {
                "letter": "C",
                "text": "wait()"
            },
            {
                "letter": "D",
                "text": "yield()"
            }
        ],
        "correct": "A",
        "explanation": "join() makes the current thread wait until another thread finishes."
    },
    {
        "title": "Lifecycle - Q0024",
        "text": "Which method is used to check if a thread has finished execution",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "isAlive()"
            },
            {
                "letter": "B",
                "text": "isFinished()"
            },
            {
                "letter": "C",
                "text": "isTerminated()"
            },
            {
                "letter": "D",
                "text": "done()"
            }
        ],
        "correct": "A",
        "explanation": "isAlive() returns false if the thread has finished execution."
    },
    {
        "title": "Lifecycle - Q0025",
        "text": "Which method is used to interrupt a thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "stop()"
            },
            {
                "letter": "B",
                "text": "interrupt()"
            },
            {
                "letter": "C",
                "text": "terminate()"
            },
            {
                "letter": "D",
                "text": "exit()"
            }
        ],
        "correct": "B",
        "explanation": "interrupt() sets the interrupt flag of the thread."
    },
    {
        "title": "Lifecycle - Q0026",
        "text": "Which method clears the interrupt flag when checking it",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "isInterrupted()"
            },
            {
                "letter": "B",
                "text": "interrupted()"
            },
            {
                "letter": "C",
                "text": "clearInterrupt()"
            },
            {
                "letter": "D",
                "text": "reset()"
            }
        ],
        "correct": "B",
        "explanation": "Thread.interrupted() checks and clears the interrupt flag."
    },
    {
        "title": "Lifecycle - Q0027",
        "text": "Which method is used to check if a thread has been interrupted without clearing the flag",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "isInterrupted()"
            },
            {
                "letter": "B",
                "text": "interrupted()"
            },
            {
                "letter": "C",
                "text": "checkInterrupt()"
            },
            {
                "letter": "D",
                "text": "hasInterrupted()"
            }
        ],
        "correct": "A",
        "explanation": "isInterrupted() checks the interrupt status without clearing it."
    },
    {
        "title": "Lifecycle - Q0028",
        "text": "Which of the following is true about daemon threads",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "They prevent JVM shutdown"
            },
            {
                "letter": "B",
                "text": "They run in the background and do not prevent JVM shutdown"
            },
            {
                "letter": "C",
                "text": "They are created by default"
            },
            {
                "letter": "D",
                "text": "They cannot be created by the user"
            }
        ],
        "correct": "B",
        "explanation": "Daemon threads run in the background and do not block JVM exit."
    },
    {
        "title": "Lifecycle - Q0029",
        "text": "Which method is used to mark a thread as daemon",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "setDaemon()"
            },
            {
                "letter": "B",
                "text": "makeDaemon()"
            },
            {
                "letter": "C",
                "text": "daemon()"
            },
            {
                "letter": "D",
                "text": "setBackground()"
            }
        ],
        "correct": "A",
        "explanation": "setDaemon(true) marks a thread as daemon."
    },
    {
        "title": "Lifecycle - Q0030",
        "text": "Which method checks if a thread is a daemon",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "isDaemon()"
            },
            {
                "letter": "B",
                "text": "checkDaemon()"
            },
            {
                "letter": "C",
                "text": "daemon()"
            },
            {
                "letter": "D",
                "text": "isBackground()"
            }
        ],
        "correct": "A",
        "explanation": "isDaemon() checks if a thread is a daemon."
    },
    {
        "title": "Lifecycle - Q0031",
        "text": "Which method is used to get the current thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Thread.current()"
            },
            {
                "letter": "B",
                "text": "Thread.get()"
            },
            {
                "letter": "C",
                "text": "Thread.currentThread()"
            },
            {
                "letter": "D",
                "text": "Thread.this()"
            }
        ],
        "correct": "C",
        "explanation": "Thread.currentThread() returns the current thread."
    },
    {
        "title": "Lifecycle - Q0032",
        "text": "Which method is used to get the name of a thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "getThreadName()"
            },
            {
                "letter": "B",
                "text": "getName()"
            },
            {
                "letter": "C",
                "text": "name()"
            },
            {
                "letter": "D",
                "text": "threadName()"
            }
        ],
        "correct": "B",
        "explanation": "getName() returns the name of the thread."
    },
    {
        "title": "Lifecycle - Q0033",
        "text": "Which method is used to set the name of a thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "setThreadName()"
            },
            {
                "letter": "B",
                "text": "setName()"
            },
            {
                "letter": "C",
                "text": "name()"
            },
            {
                "letter": "D",
                "text": "threadName()"
            }
        ],
        "correct": "B",
        "explanation": "setName() sets the name of the thread."
    },
    {
        "title": "Lifecycle - Q0034",
        "text": "Which method is used to get the ID of a thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "getThreadId()"
            },
            {
                "letter": "B",
                "text": "getId()"
            },
            {
                "letter": "C",
                "text": "id()"
            },
            {
                "letter": "D",
                "text": "threadId()"
            }
        ],
        "correct": "B",
        "explanation": "getId() returns the ID of a thread."
    },
    {
        "title": "Lifecycle - Q0035",
        "text": "Which method is used to get the priority of a thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "getPriority()"
            },
            {
                "letter": "B",
                "text": "priority()"
            },
            {
                "letter": "C",
                "text": "level()"
            },
            {
                "letter": "D",
                "text": "importance()"
            }
        ],
        "correct": "A",
        "explanation": "getPriority() returns the priority of a thread."
    },
    {
        "title": "Lifecycle - Q0036",
        "text": "Which method is used to set the priority of a thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "setPriority()"
            },
            {
                "letter": "B",
                "text": "priority()"
            },
            {
                "letter": "C",
                "text": "setLevel()"
            },
            {
                "letter": "D",
                "text": "setImportance()"
            }
        ],
        "correct": "A",
        "explanation": "setPriority() sets the priority of a thread."
    },
    {
        "title": "Lifecycle - Q0037",
        "text": "What is the default priority of a thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "1"
            },
            {
                "letter": "B",
                "text": "5"
            },
            {
                "letter": "C",
                "text": "7"
            },
            {
                "letter": "D",
                "text": "10"
            }
        ],
        "correct": "B",
        "explanation": "The default priority is 5 (NORM_PRIORITY)."
    },
    {
        "title": "Lifecycle - Q0038",
        "text": "Which method is used to get the state of a thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "getState()"
            },
            {
                "letter": "B",
                "text": "state()"
            },
            {
                "letter": "C",
                "text": "status()"
            },
            {
                "letter": "D",
                "text": "threadState()"
            }
        ],
        "correct": "A",
        "explanation": "getState() returns the current state of a thread."
    },
    {
        "title": "Lifecycle - Q0039",
        "text": "Which of the following is NOT a valid Thread.State enum",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "NEW"
            },
            {
                "letter": "B",
                "text": "RUNNABLE"
            },
            {
                "letter": "C",
                "text": "WAITING"
            },
            {
                "letter": "D",
                "text": "STOPPED"
            }
        ],
        "correct": "D",
        "explanation": "STOPPED is not a valid Thread.State enum."
    },
    {
        "title": "Lifecycle - Q0040",
        "text": "Which method is used to check if a thread is alive",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "isAlive()"
            },
            {
                "letter": "B",
                "text": "alive()"
            },
            {
                "letter": "C",
                "text": "running()"
            },
            {
                "letter": "D",
                "text": "status()"
            }
        ],
        "correct": "A",
        "explanation": "isAlive() checks if a thread is still running."
    },
    {
        "title": "Lifecycle - Q0041",
        "text": "Which method is used to make a thread wait until notified",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "wait()"
            },
            {
                "letter": "B",
                "text": "sleep()"
            },
            {
                "letter": "C",
                "text": "pause()"
            },
            {
                "letter": "D",
                "text": "yield()"
            }
        ],
        "correct": "A",
        "explanation": "wait() makes a thread wait until notified."
    },
    {
        "title": "Lifecycle - Q0042",
        "text": "Which method is used to wake up a waiting thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "notify()"
            },
            {
                "letter": "B",
                "text": "wake()"
            },
            {
                "letter": "C",
                "text": "resume()"
            },
            {
                "letter": "D",
                "text": "signal()"
            }
        ],
        "correct": "A",
        "explanation": "notify() wakes up one waiting thread."
    },
    {
        "title": "Lifecycle - Q0043",
        "text": "Which method is used to wake up all waiting threads",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "notifyAll()"
            },
            {
                "letter": "B",
                "text": "wakeAll()"
            },
            {
                "letter": "C",
                "text": "resumeAll()"
            },
            {
                "letter": "D",
                "text": "signalAll()"
            }
        ],
        "correct": "A",
        "explanation": "notifyAll() wakes up all waiting threads."
    },
    {
        "title": "Lifecycle - Q0044",
        "text": "Which method is used to pause a thread for a specific time",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "sleep()"
            },
            {
                "letter": "B",
                "text": "wait()"
            },
            {
                "letter": "C",
                "text": "yield()"
            },
            {
                "letter": "D",
                "text": "pause()"
            }
        ],
        "correct": "A",
        "explanation": "sleep() pauses a thread for a specified time."
    },
    {
        "title": "Lifecycle - Q0045",
        "text": "Which method is used to make a thread wait for another thread to finish",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "join()"
            },
            {
                "letter": "B",
                "text": "sleep()"
            },
            {
                "letter": "C",
                "text": "wait()"
            },
            {
                "letter": "D",
                "text": "yield()"
            }
        ],
        "correct": "A",
        "explanation": "join() makes one thread wait until another finishes."
    },
    {
        "title": "Lifecycle - Q0046",
        "text": "Which method is used to voluntarily give up CPU control",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "yield()"
            },
            {
                "letter": "B",
                "text": "sleep()"
            },
            {
                "letter": "C",
                "text": "wait()"
            },
            {
                "letter": "D",
                "text": "pause()"
            }
        ],
        "correct": "A",
        "explanation": "yield() hints the scheduler to give other threads a chance to run."
    },
    {
        "title": "Lifecycle - Q0047",
        "text": "Which method is used to stop a thread safely",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "stop()"
            },
            {
                "letter": "B",
                "text": "destroy()"
            },
            {
                "letter": "C",
                "text": "interrupt()"
            },
            {
                "letter": "D",
                "text": "exit()"
            }
        ],
        "correct": "C",
        "explanation": "interrupt() is the safe way to request a thread to stop."
    },
    {
        "title": "Lifecycle - Q0048",
        "text": "Which state does a thread enter after calling sleep()",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "WAITING"
            },
            {
                "letter": "B",
                "text": "TIMED_WAITING"
            },
            {
                "letter": "C",
                "text": "BLOCKED"
            },
            {
                "letter": "D",
                "text": "TERMINATED"
            }
        ],
        "correct": "B",
        "explanation": "sleep() puts the thread into TIMED_WAITING."
    },
    {
        "title": "Lifecycle - Q0049",
        "text": "Which state does a thread enter after calling join()",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "WAITING or TIMED_WAITING"
            },
            {
                "letter": "B",
                "text": "BLOCKED"
            },
            {
                "letter": "C",
                "text": "RUNNABLE"
            },
            {
                "letter": "D",
                "text": "TERMINATED"
            }
        ],
        "correct": "A",
        "explanation": "join() puts the thread into WAITING or TIMED_WAITING depending on overload."
    },
    {
        "title": "Lifecycle - Q0050",
        "text": "Which state does a thread enter after finishing execution",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "RUNNABLE"
            },
            {
                "letter": "B",
                "text": "WAITING"
            },
            {
                "letter": "C",
                "text": "TERMINATED"
            },
            {
                "letter": "D",
                "text": "BLOCKED"
            }
        ],
        "correct": "C",
        "explanation": "TERMINATED means the thread has finished execution."
    },
    {
        "title": "Synchronization - Q0001",
        "text": "What is synchronization in Java",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "A mechanism to stop threads"
            },
            {
                "letter": "B",
                "text": "A mechanism to control access to shared resources"
            },
            {
                "letter": "C",
                "text": "A mechanism to create threads"
            },
            {
                "letter": "D",
                "text": "A mechanism to terminate JVM"
            }
        ],
        "correct": "B",
        "explanation": "Synchronization ensures that only one thread accesses a shared resource at a time."
    },
    {
        "title": "Synchronization - Q0002",
        "text": "Which keyword is used to synchronize methods or blocks in Java",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "sync"
            },
            {
                "letter": "B",
                "text": "synchronized"
            },
            {
                "letter": "C",
                "text": "lock"
            },
            {
                "letter": "D",
                "text": "atomic"
            }
        ],
        "correct": "B",
        "explanation": "The 'synchronized' keyword is used to synchronize methods or blocks."
    },
    {
        "title": "Synchronization - Q0003",
        "text": "Which of the following can be synchronized",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Methods only"
            },
            {
                "letter": "B",
                "text": "Blocks only"
            },
            {
                "letter": "C",
                "text": "Both methods and blocks"
            },
            {
                "letter": "D",
                "text": "Classes only"
            }
        ],
        "correct": "C",
        "explanation": "Both methods and blocks can be synchronized in Java."
    },
    {
        "title": "Synchronization - Q0004",
        "text": "What is the default lock used in synchronized methods",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Class object"
            },
            {
                "letter": "B",
                "text": "Object instance"
            },
            {
                "letter": "C",
                "text": "Thread object"
            },
            {
                "letter": "D",
                "text": "Monitor object"
            }
        ],
        "correct": "B",
        "explanation": "For instance methods, the lock is the object instance."
    },
    {
        "title": "Synchronization - Q0005",
        "text": "What is the lock used for static synchronized methods",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Object instance"
            },
            {
                "letter": "B",
                "text": "Thread object"
            },
            {
                "letter": "C",
                "text": "Class object"
            },
            {
                "letter": "D",
                "text": "Monitor object"
            }
        ],
        "correct": "C",
        "explanation": "Static synchronized methods use the class object as the lock."
    },
    {
        "title": "Synchronization - Q0006",
        "text": "Which of the following is true about synchronized blocks",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "They can lock on any object"
            },
            {
                "letter": "B",
                "text": "They can only lock on 'this'"
            },
            {
                "letter": "C",
                "text": "They cannot be nested"
            },
            {
                "letter": "D",
                "text": "They cannot be used in static methods"
            }
        ],
        "correct": "A",
        "explanation": "Synchronized blocks can lock on any object reference."
    },
    {
        "title": "Synchronization - Q0007",
        "text": "Which of the following is NOT a problem solved by synchronization",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Race conditions"
            },
            {
                "letter": "B",
                "text": "Data inconsistency"
            },
            {
                "letter": "C",
                "text": "Deadlocks"
            },
            {
                "letter": "D",
                "text": "Thread interference"
            }
        ],
        "correct": "C",
        "explanation": "Synchronization can cause deadlocks but does not solve them."
    },
    {
        "title": "Synchronization - Q0008",
        "text": "Which method is used to make a thread wait inside a synchronized block",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "sleep()"
            },
            {
                "letter": "B",
                "text": "wait()"
            },
            {
                "letter": "C",
                "text": "pause()"
            },
            {
                "letter": "D",
                "text": "yield()"
            }
        ],
        "correct": "B",
        "explanation": "wait() is used inside synchronized blocks to make a thread wait."
    },
    {
        "title": "Synchronization - Q0009",
        "text": "Which method is used to wake up a single waiting thread",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "notify()"
            },
            {
                "letter": "B",
                "text": "notifyAll()"
            },
            {
                "letter": "C",
                "text": "signal()"
            },
            {
                "letter": "D",
                "text": "resume()"
            }
        ],
        "correct": "A",
        "explanation": "notify() wakes up one waiting thread."
    },
    {
        "title": "Synchronization - Q0010",
        "text": "Which method is used to wake up all waiting threads",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "notify()"
            },
            {
                "letter": "B",
                "text": "notifyAll()"
            },
            {
                "letter": "C",
                "text": "signalAll()"
            },
            {
                "letter": "D",
                "text": "resumeAll()"
            }
        ],
        "correct": "B",
        "explanation": "notifyAll() wakes up all waiting threads."
    },
    {
        "title": "Synchronization - Q0011",
        "text": "Which package provides Lock and ReentrantLock classes",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "java.lang"
            },
            {
                "letter": "B",
                "text": "java.util.concurrent.locks"
            },
            {
                "letter": "C",
                "text": "java.util.concurrent"
            },
            {
                "letter": "D",
                "text": "java.thread"
            }
        ],
        "correct": "B",
        "explanation": "Lock and ReentrantLock are in java.util.concurrent.locks."
    },
    {
        "title": "Synchronization - Q0012",
        "text": "Which interface is implemented by ReentrantLock",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Lock"
            },
            {
                "letter": "B",
                "text": "Runnable"
            },
            {
                "letter": "C",
                "text": "Callable"
            },
            {
                "letter": "D",
                "text": "ThreadSafe"
            }
        ],
        "correct": "A",
        "explanation": "ReentrantLock implements the Lock interface."
    },
    {
        "title": "Synchronization - Q0013",
        "text": "Which method of Lock is used to acquire a lock",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "lock()"
            },
            {
                "letter": "B",
                "text": "acquire()"
            },
            {
                "letter": "C",
                "text": "get()"
            },
            {
                "letter": "D",
                "text": "obtain()"
            }
        ],
        "correct": "A",
        "explanation": "lock() is used to acquire a lock."
    },
    {
        "title": "Synchronization - Q0014",
        "text": "Which method of Lock is used to release a lock",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "unlock()"
            },
            {
                "letter": "B",
                "text": "release()"
            },
            {
                "letter": "C",
                "text": "free()"
            },
            {
                "letter": "D",
                "text": "exit()"
            }
        ],
        "correct": "A",
        "explanation": "unlock() is used to release a lock."
    },
    {
        "title": "Synchronization - Q0015",
        "text": "Which of the following is true about synchronized collections",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "They are created using Collections.synchronizedXXX()"
            },
            {
                "letter": "B",
                "text": "They are created using Thread.synchronized()"
            },
            {
                "letter": "C",
                "text": "They are created using Lock.synchronized()"
            },
            {
                "letter": "D",
                "text": "They are created using Atomic classes"
            }
        ],
        "correct": "A",
        "explanation": "Collections.synchronizedXXX() creates synchronized collections."
    },
    {
        "title": "Synchronization - Q0016",
        "text": "Which of the following is NOT a concurrent collection",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "ConcurrentHashMap"
            },
            {
                "letter": "B",
                "text": "CopyOnWriteArrayList"
            },
            {
                "letter": "C",
                "text": "Vector"
            },
            {
                "letter": "D",
                "text": "ConcurrentLinkedQueue"
            }
        ],
        "correct": "C",
        "explanation": "Vector is synchronized but not part of java.util.concurrent."
    },
    {
        "title": "Synchronization - Q0017",
        "text": "Which class provides atomic operations on integers",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "AtomicInteger"
            },
            {
                "letter": "B",
                "text": "Integer"
            },
            {
                "letter": "C",
                "text": "AtomicNumber"
            },
            {
                "letter": "D",
                "text": "ConcurrentInteger"
            }
        ],
        "correct": "A",
        "explanation": "AtomicInteger provides atomic operations on integers."
    },
    {
        "title": "Synchronization - Q0018",
        "text": "Which of the following is true about volatile variables",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "They guarantee atomicity"
            },
            {
                "letter": "B",
                "text": "They guarantee visibility across threads"
            },
            {
                "letter": "C",
                "text": "They guarantee ordering of operations"
            },
            {
                "letter": "D",
                "text": "They guarantee mutual exclusion"
            }
        ],
        "correct": "B",
        "explanation": "Volatile ensures visibility but not atomicity."
    },
    {
        "title": "Synchronization - Q0019",
        "text": "Which of the following is NOT a synchronization utility in java.util.concurrent",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Semaphore"
            },
            {
                "letter": "B",
                "text": "CountDownLatch"
            },
            {
                "letter": "C",
                "text": "CyclicBarrier"
            },
            {
                "letter": "D",
                "text": "ThreadGroup"
            }
        ],
        "correct": "D",
        "explanation": "ThreadGroup is not a synchronization utility."
    },
    {
        "title": "Synchronization - Q0020",
        "text": "Which synchronization utility allows a fixed number of threads to access a resource",
        "code": "",
        "options": [
            {
                "letter": "A",
                "text": "Semaphore"
            },
            {
                "letter": "B",
                "text": "CountDownLatch"
            },
            {
                "letter": "C",
                "text": "CyclicBarrier"
            },
            {
                "letter": "D",
                "text": "Exchanger"
            }
        ],
        "correct": "A",
        "explanation": "Semaphore controls the number of threads accessing a resource."
    },
    {
        "title": "Synchronization - Q0021",
        "text": "Which synchronization utility allows threads to wait until a set of operations complete",
        "options": [
            {
                "letter": "A",
                "text": "Semaphore"
            },
            {
                "letter": "B",
                "text": "CountDownLatch"
            },
            {
                "letter": "C",
                "text": "CyclicBarrier"
            },
            {
                "letter": "D",
                "text": "Exchanger"
            }
        ],
        "correct": "B",
        "explanation": "CountDownLatch allows threads to wait until a set of operations complete."
    },
    {
        "title": "Synchronization - Q0022",
        "text": "Which synchronization utility allows a group of threads to wait for each other to reach a common barrier point",
        "options": [
            {
                "letter": "A",
                "text": "Semaphore"
            },
            {
                "letter": "B",
                "text": "CountDownLatch"
            },
            {
                "letter": "C",
                "text": "CyclicBarrier"
            },
            {
                "letter": "D",
                "text": "Exchanger"
            }
        ],
        "correct": "C",
        "explanation": "CyclicBarrier allows a group of threads to wait for each other at a barrier point."
    },
    {
        "title": "Synchronization - Q0023",
        "text": "Which synchronization utility allows two threads to exchange data",
        "options": [
            {
                "letter": "A",
                "text": "Semaphore"
            },
            {
                "letter": "B",
                "text": "CountDownLatch"
            },
            {
                "letter": "C",
                "text": "CyclicBarrier"
            },
            {
                "letter": "D",
                "text": "Exchanger"
            }
        ],
        "correct": "D",
        "explanation": "Exchanger allows two threads to exchange data objects."
    },
    {
        "title": "Synchronization - Q0024",
        "text": "Which of the following is true about synchronized keyword",
        "options": [
            {
                "letter": "A",
                "text": "It can be applied to variables"
            },
            {
                "letter": "B",
                "text": "It can be applied to methods and blocks"
            },
            {
                "letter": "C",
                "text": "It can be applied to classes only"
            },
            {
                "letter": "D",
                "text": "It can be applied to interfaces"
            }
        ],
        "correct": "B",
        "explanation": "The synchronized keyword can be applied to methods and blocks."
    },
    {
        "title": "Synchronization - Q0025",
        "text": "Which of the following is NOT true about synchronized methods",
        "options": [
            {
                "letter": "A",
                "text": "They lock the object instance"
            },
            {
                "letter": "B",
                "text": "They can be static"
            },
            {
                "letter": "C",
                "text": "They can be overridden without synchronization"
            },
            {
                "letter": "D",
                "text": "They guarantee fairness among threads"
            }
        ],
        "correct": "D",
        "explanation": "Synchronized methods do not guarantee fairness among threads."
    },
    {
        "title": "Synchronization - Q0026",
        "text": "Which of the following is true about ReentrantLock",
        "options": [
            {
                "letter": "A",
                "text": "It allows a thread to acquire the same lock multiple times"
            },
            {
                "letter": "B",
                "text": "It cannot be interrupted"
            },
            {
                "letter": "C",
                "text": "It does not support fairness"
            },
            {
                "letter": "D",
                "text": "It cannot be unlocked"
            }
        ],
        "correct": "A",
        "explanation": "ReentrantLock allows a thread to acquire the same lock multiple times."
    },
    {
        "title": "Synchronization - Q0027",
        "text": "Which method of ReentrantLock tries to acquire the lock without waiting",
        "options": [
            {
                "letter": "A",
                "text": "lock()"
            },
            {
                "letter": "B",
                "text": "tryLock()"
            },
            {
                "letter": "C",
                "text": "unlock()"
            },
            {
                "letter": "D",
                "text": "acquire()"
            }
        ],
        "correct": "B",
        "explanation": "tryLock() attempts to acquire the lock without waiting."
    },
    {
        "title": "Synchronization - Q0028",
        "text": "Which of the following is true about synchronized blocks",
        "options": [
            {
                "letter": "A",
                "text": "They are more granular than synchronized methods"
            },
            {
                "letter": "B",
                "text": "They always lock the entire class"
            },
            {
                "letter": "C",
                "text": "They cannot specify a lock object"
            },
            {
                "letter": "D",
                "text": "They are slower than synchronized methods"
            }
        ],
        "correct": "A",
        "explanation": "Synchronized blocks allow finer control by locking only specific code sections."
    },
    {
        "title": "Synchronization - Q0029",
        "text": "Which of the following is NOT a feature of Semaphore",
        "options": [
            {
                "letter": "A",
                "text": "It controls access to resources"
            },
            {
                "letter": "B",
                "text": "It can be fair or non-fair"
            },
            {
                "letter": "C",
                "text": "It allows multiple permits"
            },
            {
                "letter": "D",
                "text": "It guarantees mutual exclusion"
            }
        ],
        "correct": "D",
        "explanation": "Semaphore does not guarantee mutual exclusion unless only one permit is used."
    },
    {
        "title": "Synchronization - Q0030",
        "text": "Which of the following is true about synchronized collections",
        "options": [
            {
                "letter": "A",
                "text": "They are created using Collections.synchronizedXXX()"
            },
            {
                "letter": "B",
                "text": "They are always faster than concurrent collections"
            },
            {
                "letter": "C",
                "text": "They cannot be iterated safely"
            },
            {
                "letter": "D",
                "text": "They are deprecated"
            }
        ],
        "correct": "A",
        "explanation": "Collections.synchronizedXXX() creates synchronized versions of collections."
    },
    {
        "title": "Synchronization - Q0031",
        "text": "Which concurrent collection allows thread-safe iteration without locking",
        "options": [
            {
                "letter": "A",
                "text": "Vector"
            },
            {
                "letter": "B",
                "text": "CopyOnWriteArrayList"
            },
            {
                "letter": "C",
                "text": "Hashtable"
            },
            {
                "letter": "D",
                "text": "SynchronizedList"
            }
        ],
        "correct": "B",
        "explanation": "CopyOnWriteArrayList allows safe iteration without explicit locking."
    },
    {
        "title": "Synchronization - Q0032",
        "text": "Which concurrent collection is a thread-safe alternative to HashMap",
        "options": [
            {
                "letter": "A",
                "text": "ConcurrentHashMap"
            },
            {
                "letter": "B",
                "text": "Hashtable"
            },
            {
                "letter": "C",
                "text": "SynchronizedMap"
            },
            {
                "letter": "D",
                "text": "TreeMap"
            }
        ],
        "correct": "A",
        "explanation": "ConcurrentHashMap is a thread-safe alternative to HashMap."
    },
    {
        "title": "Synchronization - Q0033",
        "text": "Which of the following is true about volatile variables",
        "options": [
            {
                "letter": "A",
                "text": "They guarantee atomicity"
            },
            {
                "letter": "B",
                "text": "They guarantee visibility across threads"
            },
            {
                "letter": "C",
                "text": "They guarantee mutual exclusion"
            },
            {
                "letter": "D",
                "text": "They guarantee fairness"
            }
        ],
        "correct": "B",
        "explanation": "Volatile ensures visibility of changes across threads but not atomicity."
    },
    {
        "title": "Synchronization - Q0034",
        "text": "Which of the following is NOT a valid use of synchronized keyword",
        "options": [
            {
                "letter": "A",
                "text": "Synchronized method"
            },
            {
                "letter": "B",
                "text": "Synchronized block"
            },
            {
                "letter": "C",
                "text": "Synchronized variable"
            },
            {
                "letter": "D",
                "text": "Static synchronized method"
            }
        ],
        "correct": "C",
        "explanation": "Variables cannot be declared synchronized."
    },
    {
        "title": "Synchronization - Q0035",
        "text": "Which of the following is true about deadlocks",
        "options": [
            {
                "letter": "A",
                "text": "They occur when threads wait indefinitely for locks"
            },
            {
                "letter": "B",
                "text": "They are automatically resolved by JVM"
            },
            {
                "letter": "C",
                "text": "They cannot occur in synchronized code"
            },
            {
                "letter": "D",
                "text": "They are prevented by volatile keyword"
            }
        ],
        "correct": "A",
        "explanation": "Deadlocks occur when threads wait indefinitely for each others locks."
    },
    {
        "title": "Synchronization - Q0036",
        "text": "Which of the following is true about livelock",
        "options": [
            {
                "letter": "A",
                "text": "Threads are blocked forever"
            },
            {
                "letter": "B",
                "text": "Threads keep changing state but make no progress"
            },
            {
                "letter": "C",
                "text": "Threads terminate immediately"
            },
            {
                "letter": "D",
                "text": "Threads are paused by JVM"
            }
        ],
        "correct": "B",
        "explanation": "In livelock, threads keep changing state but do not make progress."
    },
    {
        "title": "Synchronization - Q0037",
        "text": "Which of the following is true about starvation",
        "options": [
            {
                "letter": "A",
                "text": "A thread never gets CPU time"
            },
            {
                "letter": "B",
                "text": "A thread is blocked forever"
            },
            {
                "letter": "C",
                "text": "A thread is terminated"
            },
            {
                "letter": "D",
                "text": "A thread is interrupted"
            }
        ],
        "correct": "A",
        "explanation": "Starvation occurs when a thread never gets CPU time due to scheduling."
    },
    {
        "title": "Synchronization - Q0038",
        "text": "Which of the following is true about fairness in locks",
        "options": [
            {
                "letter": "A",
                "text": "Fair locks grant access in order of requests"
            },
            {
                "letter": "B",
                "text": "Fair locks are always faster"
            },
            {
                "letter": "C",
                "text": "Fair locks prevent deadlocks"
            },
            {
                "letter": "D",
                "text": "Fair locks are default in ReentrantLock"
            }
        ],
        "correct": "A",
        "explanation": "Fair locks grant access in the order threads requested it."
    },
    {
        "title": "Synchronization - Q0039",
        "text": "Which method of Condition is used to make a thread wait",
        "options": [
            {
                "letter": "A",
                "text": "await()"
            },
            {
                "letter": "B",
                "text": "wait()"
            },
            {
                "letter": "C",
                "text": "sleep()"
            },
            {
                "letter": "D",
                "text": "pause()"
            }
        ],
        "correct": "A",
        "explanation": "await() is used with Condition to make a thread wait."
    },
    {
        "title": "Synchronization - Q0040",
        "text": "Which method of Condition is used to wake up one waiting thread",
        "options": [
            {
                "letter": "A",
                "text": "signal()"
            },
            {
                "letter": "B",
                "text": "notify()"
            },
            {
                "letter": "C",
                "text": "resume()"
            },
            {
                "letter": "D",
                "text": "wake()"
            }
        ],
        "correct": "A",
        "explanation": "signal() wakes up one waiting thread in Condition."
    },
    {
        "title": "Synchronization - Q0041",
        "text": "Which method of Condition is used to wake up all waiting threads",
        "options": [
            {
                "letter": "A",
                "text": "signalAll()"
            },
            {
                "letter": "B",
                "text": "notifyAll()"
            },
            {
                "letter": "C",
                "text": "resumeAll()"
            },
            {
                "letter": "D",
                "text": "wakeAll()"
            }
        ],
        "correct": "A",
        "explanation": "signalAll() wakes up all waiting threads in Condition."
    },
    {
        "title": "Synchronization - Q0042",
        "text": "Which of the following is true about synchronized keyword performance",
        "options": [
            {
                "letter": "A",
                "text": "It is always faster than Lock"
            },
            {
                "letter": "B",
                "text": "It may cause contention and reduce performance"
            },
            {
                "letter": "C",
                "text": "It guarantees fairness"
            },
            {
                "letter": "D",
                "text": "It prevents deadlocks"
            }
        ],
        "correct": "B",
        "explanation": "Synchronized may cause contention and reduce performance."
    },
    {
        "title": "Synchronization - Q0043",
        "text": "Which of the following is true about Atomic classes",
        "options": [
            {
                "letter": "A",
                "text": "They provide lock-free thread-safe operations"
            },
            {
                "letter": "B",
                "text": "They require explicit synchronization"
            },
            {
                "letter": "C",
                "text": "They are slower than synchronized blocks"
            },
            {
                "letter": "D",
                "text": "They are deprecated"
            }
        ],
        "correct": "A",
        "explanation": "Atomic classes provide lock-free thread-safe operations."
    },
    {
        "title": "Synchronization - Q0044",
        "text": "Which of the following is NOT an Atomic class",
        "options": [
            {
                "letter": "A",
                "text": "AtomicInteger"
            },
            {
                "letter": "B",
                "text": "AtomicLong"
            },
            {
                "letter": "C",
                "text": "AtomicBoolean"
            },
            {
                "letter": "D",
                "text": "AtomicString"
            }
        ],
        "correct": "D",
        "explanation": "There is no AtomicString class in Java."
    },
    {
        "title": "Synchronization - Q0045",
        "text": "Which of the following is true about ReadWriteLock",
        "options": [
            {
                "letter": "A",
                "text": "It allows multiple readers but only one writer"
            },
            {
                "letter": "B",
                "text": "It allows multiple writers"
            },
            {
                "letter": "C",
                "text": "It does not allow readers"
            },
            {
                "letter": "D",
                "text": "It is deprecated"
            }
        ],
        "correct": "A",
        "explanation": "ReadWriteLock allows multiple readers but only one writer."
    },
    {
        "title": "Synchronization - Q0046",
        "text": "Which implementation of ReadWriteLock is provided in Java",
        "options": [
            {
                "letter": "A",
                "text": "ReentrantReadWriteLock"
            },
            {
                "letter": "B",
                "text": "SimpleReadWriteLock"
            },
            {
                "letter": "C",
                "text": "ConcurrentReadWriteLock"
            },
            {
                "letter": "D",
                "text": "AtomicReadWriteLock"
            }
        ],
        "correct": "A",
        "explanation": "ReentrantReadWriteLock is the implementation provided in Java."
    },
    {
        "title": "Synchronization - Q0047",
        "text": "Which of the following is true about synchronized keyword and exceptions",
        "options": [
            {
                "letter": "A",
                "text": "Locks are not released if an exception occurs"
            },
            {
                "letter": "B",
                "text": "Locks are automatically released when an exception occurs"
            },
            {
                "letter": "C",
                "text": "Locks must be manually released"
            },
            {
                "letter": "D",
                "text": "Locks are ignored during exceptions"
            }
        ],
        "correct": "B",
        "explanation": "Locks are automatically released if an exception occurs in synchronized code."
    },
    {
        "title": "Synchronization - Q0048",
        "text": "Which of the following is true about Lock interface and exceptions",
        "options": [
            {
                "letter": "A",
                "text": "Locks are automatically released on exceptions"
            },
            {
                "letter": "B",
                "text": "Locks must be released manually in finally block"
            },
            {
                "letter": "C",
                "text": "Locks are ignored during exceptions"
            },
            {
                "letter": "D",
                "text": "Locks are released by JVM automatically"
            }
        ],
        "correct": "B",
        "explanation": "Locks must be released manually in a finally block when using Lock interface."
    },
    {
        "title": "Synchronization - Q0049",
        "text": "Which of the following is true about synchronized keyword and inheritance",
        "options": [
            {
                "letter": "A",
                "text": "Synchronized methods remain synchronized when overridden"
            },
            {
                "letter": "B",
                "text": "Synchronized methods lose synchronization when overridden"
            },
            {
                "letter": "C",
                "text": "Synchronized methods cannot be overridden"
            },
            {
                "letter": "D",
                "text": "Synchronized methods become static when overridden"
            }
        ],
        "correct": "B",
        "explanation": "Overridden methods do not inherit synchronization; they must be explicitly synchronized."
    },
    {
        "title": "Synchronization - Q0050",
        "text": "Which of the following is true about synchronized keyword and static methods",
        "options": [
            {
                "letter": "A",
                "text": "They lock the class object"
            },
            {
                "letter": "B",
                "text": "They lock the instance object"
            },
            {
                "letter": "C",
                "text": "They lock the thread object"
            },
            {
                "letter": "D",
                "text": "They lock the monitor object"
            }
        ],
        "correct": "A",
        "explanation": "Static synchronized methods lock the class object."
    },
    {
        "title": "ThreadPools - Q0001",
        "text": "What is a thread pool in Java",
        "options": [
            {
                "letter": "A",
                "text": "A collection of threads that can be reused to execute tasks"
            },
            {
                "letter": "B",
                "text": "A mechanism to create new threads for each task"
            },
            {
                "letter": "C",
                "text": "A group of threads that run sequentially"
            },
            {
                "letter": "D",
                "text": "A set of daemon threads only"
            }
        ],
        "correct": "A",
        "explanation": "A thread pool is a collection of worker threads that can be reused to execute multiple tasks."
    },
    {
        "title": "ThreadPools - Q0002",
        "text": "Which package provides thread pool implementations in Java",
        "options": [
            {
                "letter": "A",
                "text": "java.lang"
            },
            {
                "letter": "B",
                "text": "java.util.concurrent"
            },
            {
                "letter": "C",
                "text": "java.thread"
            },
            {
                "letter": "D",
                "text": "java.pool"
            }
        ],
        "correct": "B",
        "explanation": "Thread pool implementations are provided in java.util.concurrent."
    },
    {
        "title": "ThreadPools - Q0003",
        "text": "Which class provides factory methods to create thread pools",
        "options": [
            {
                "letter": "A",
                "text": "Executors"
            },
            {
                "letter": "B",
                "text": "Executor"
            },
            {
                "letter": "C",
                "text": "ThreadPool"
            },
            {
                "letter": "D",
                "text": "ThreadFactory"
            }
        ],
        "correct": "A",
        "explanation": "Executors class provides factory methods to create thread pools."
    },
    {
        "title": "ThreadPools - Q0004",
        "text": "Which method creates a fixed-size thread pool",
        "options": [
            {
                "letter": "A",
                "text": "Executors.newFixedThreadPool()"
            },
            {
                "letter": "B",
                "text": "Executors.newCachedThreadPool()"
            },
            {
                "letter": "C",
                "text": "Executors.newSingleThreadExecutor()"
            },
            {
                "letter": "D",
                "text": "Executors.newScheduledThreadPool()"
            }
        ],
        "correct": "A",
        "explanation": "newFixedThreadPool() creates a pool with a fixed number of threads."
    },
    {
        "title": "ThreadPools - Q0005",
        "text": "Which method creates a thread pool that creates new threads as needed",
        "options": [
            {
                "letter": "A",
                "text": "Executors.newFixedThreadPool()"
            },
            {
                "letter": "B",
                "text": "Executors.newCachedThreadPool()"
            },
            {
                "letter": "C",
                "text": "Executors.newSingleThreadExecutor()"
            },
            {
                "letter": "D",
                "text": "Executors.newScheduledThreadPool()"
            }
        ],
        "correct": "B",
        "explanation": "newCachedThreadPool() creates new threads as needed and reuses idle ones."
    },
    {
        "title": "ThreadPools - Q0006",
        "text": "Which method creates a single-threaded executor",
        "options": [
            {
                "letter": "A",
                "text": "Executors.newFixedThreadPool()"
            },
            {
                "letter": "B",
                "text": "Executors.newCachedThreadPool()"
            },
            {
                "letter": "C",
                "text": "Executors.newSingleThreadExecutor()"
            },
            {
                "letter": "D",
                "text": "Executors.newScheduledThreadPool()"
            }
        ],
        "correct": "C",
        "explanation": "newSingleThreadExecutor() creates a pool with only one thread."
    },
    {
        "title": "ThreadPools - Q0007",
        "text": "Which method creates a thread pool that can schedule tasks",
        "options": [
            {
                "letter": "A",
                "text": "Executors.newFixedThreadPool()"
            },
            {
                "letter": "B",
                "text": "Executors.newCachedThreadPool()"
            },
            {
                "letter": "C",
                "text": "Executors.newSingleThreadExecutor()"
            },
            {
                "letter": "D",
                "text": "Executors.newScheduledThreadPool()"
            }
        ],
        "correct": "D",
        "explanation": "newScheduledThreadPool() creates a pool that can schedule tasks."
    },
    {
        "title": "ThreadPools - Q0008",
        "text": "Which interface represents an object that executes submitted tasks",
        "options": [
            {
                "letter": "A",
                "text": "Executor"
            },
            {
                "letter": "B",
                "text": "Executors"
            },
            {
                "letter": "C",
                "text": "ExecutorService"
            },
            {
                "letter": "D",
                "text": "ThreadPoolExecutor"
            }
        ],
        "correct": "A",
        "explanation": "Executor is the base interface for executing submitted tasks."
    },
    {
        "title": "ThreadPools - Q0009",
        "text": "Which interface extends Executor and provides lifecycle management",
        "options": [
            {
                "letter": "A",
                "text": "ExecutorService"
            },
            {
                "letter": "B",
                "text": "Executors"
            },
            {
                "letter": "C",
                "text": "ThreadPoolExecutor"
            },
            {
                "letter": "D",
                "text": "ScheduledExecutorService"
            }
        ],
        "correct": "A",
        "explanation": "ExecutorService extends Executor and provides lifecycle management methods."
    },
    {
        "title": "ThreadPools - Q0010",
        "text": "Which method of ExecutorService submits a task without returning a result",
        "options": [
            {
                "letter": "A",
                "text": "submit()"
            },
            {
                "letter": "B",
                "text": "execute()"
            },
            {
                "letter": "C",
                "text": "invokeAll()"
            },
            {
                "letter": "D",
                "text": "invokeAny()"
            }
        ],
        "correct": "B",
        "explanation": "execute() submits a task without returning a result."
    },
    {
        "title": "ThreadPools - Q0011",
        "text": "Which method of ExecutorService submits a task and returns a Future",
        "options": [
            {
                "letter": "A",
                "text": "submit()"
            },
            {
                "letter": "B",
                "text": "execute()"
            },
            {
                "letter": "C",
                "text": "invokeAll()"
            },
            {
                "letter": "D",
                "text": "invokeAny()"
            }
        ],
        "correct": "A",
        "explanation": "submit() submits a task and returns a Future representing the result."
    },
    {
        "title": "ThreadPools - Q0012",
        "text": "Which method of ExecutorService shuts down the executor gracefully",
        "options": [
            {
                "letter": "A",
                "text": "shutdown()"
            },
            {
                "letter": "B",
                "text": "shutdownNow()"
            },
            {
                "letter": "C",
                "text": "terminate()"
            },
            {
                "letter": "D",
                "text": "stop()"
            }
        ],
        "correct": "A",
        "explanation": "shutdown() initiates an orderly shutdown where previously submitted tasks are executed."
    },
    {
        "title": "ThreadPools - Q0013",
        "text": "Which method of ExecutorService attempts to stop all actively executing tasks",
        "options": [
            {
                "letter": "A",
                "text": "shutdown()"
            },
            {
                "letter": "B",
                "text": "shutdownNow()"
            },
            {
                "letter": "C",
                "text": "terminate()"
            },
            {
                "letter": "D",
                "text": "stop()"
            }
        ],
        "correct": "B",
        "explanation": "shutdownNow() attempts to stop all actively executing tasks immediately."
    },
    {
        "title": "ThreadPools - Q0014",
        "text": "Which method of ExecutorService blocks until all tasks complete or timeout occurs",
        "options": [
            {
                "letter": "A",
                "text": "awaitTermination()"
            },
            {
                "letter": "B",
                "text": "wait()"
            },
            {
                "letter": "C",
                "text": "join()"
            },
            {
                "letter": "D",
                "text": "sleep()"
            }
        ],
        "correct": "A",
        "explanation": "awaitTermination() blocks until all tasks complete or timeout occurs."
    },
    {
        "title": "ThreadPools - Q0015",
        "text": "Which class is the most configurable implementation of ExecutorService",
        "options": [
            {
                "letter": "A",
                "text": "ThreadPoolExecutor"
            },
            {
                "letter": "B",
                "text": "Executors"
            },
            {
                "letter": "C",
                "text": "ScheduledThreadPoolExecutor"
            },
            {
                "letter": "D",
                "text": "ForkJoinPool"
            }
        ],
        "correct": "A",
        "explanation": "ThreadPoolExecutor is the most configurable implementation of ExecutorService."
    },
    {
        "title": "ThreadPools - Q0016",
        "text": "Which parameters define a ThreadPoolExecutor",
        "options": [
            {
                "letter": "A",
                "text": "Core pool size, maximum pool size, keep-alive time, work queue"
            },
            {
                "letter": "B",
                "text": "Thread name, thread priority, thread group"
            },
            {
                "letter": "C",
                "text": "Thread ID, thread state, thread priority"
            },
            {
                "letter": "D",
                "text": "Thread factory, thread group, thread ID"
            }
        ],
        "correct": "A",
        "explanation": "ThreadPoolExecutor is defined by core pool size, maximum pool size, keep-alive time, and work queue."
    },
    {
        "title": "ThreadPools - Q0017",
        "text": "What is the default work queue used in ThreadPoolExecutor",
        "options": [
            {
                "letter": "A",
                "text": "ArrayBlockingQueue"
            },
            {
                "letter": "B",
                "text": "LinkedBlockingQueue"
            },
            {
                "letter": "C",
                "text": "PriorityBlockingQueue"
            },
            {
                "letter": "D",
                "text": "SynchronousQueue"
            }
        ],
        "correct": "B",
        "explanation": "LinkedBlockingQueue is commonly used as the default work queue."
    },
    {
        "title": "ThreadPools - Q0018",
        "text": "Which method of ExecutorService executes a collection of tasks and returns a list of Futures",
        "options": [
            {
                "letter": "A",
                "text": "submit()"
            },
            {
                "letter": "B",
                "text": "execute()"
            },
            {
                "letter": "C",
                "text": "invokeAll()"
            },
            {
                "letter": "D",
                "text": "invokeAny()"
            }
        ],
        "correct": "C",
        "explanation": "invokeAll() executes a collection of tasks and returns a list of Futures."
    },
    {
        "title": "ThreadPools - Q0019",
        "text": "Which method of ExecutorService executes a collection of tasks and returns the result of one that completes successfully",
        "options": [
            {
                "letter": "A",
                "text": "submit()"
            },
            {
                "letter": "B",
                "text": "execute()"
            },
            {
                "letter": "C",
                "text": "invokeAll()"
            },
            {
                "letter": "D",
                "text": "invokeAny()"
            }
        ],
        "correct": "D",
        "explanation": "invokeAny() returns the result of one successfully completed task."
    },
    {
        "title": "ThreadPools - Q0020",
        "text": "Which thread pool is best suited for executing periodic tasks",
        "options": [
            {
                "letter": "A",
                "text": "FixedThreadPool"
            },
            {
                "letter": "B",
                "text": "CachedThreadPool"
            },
            {
                "letter": "C",
                "text": "ScheduledThreadPool"
            },
            {
                "letter": "D",
                "text": "SingleThreadExecutor"
            }
        ],
        "correct": "C",
        "explanation": "ScheduledThreadPool is designed for executing periodic or delayed tasks."
    },
    {
        "title": "ThreadPools - Q0021",
        "text": "Which method schedules a task to run after a delay",
        "options": [
            {
                "letter": "A",
                "text": "schedule()"
            },
            {
                "letter": "B",
                "text": "scheduleAtFixedRate()"
            },
            {
                "letter": "C",
                "text": "scheduleWithFixedDelay()"
            },
            {
                "letter": "D",
                "text": "submit()"
            }
        ],
        "correct": "A",
        "explanation": "schedule() runs a task after a specified delay."
    },
    {
        "title": "ThreadPools - Q0022",
        "text": "Which method schedules a task to run repeatedly at a fixed rate",
        "options": [
            {
                "letter": "A",
                "text": "schedule()"
            },
            {
                "letter": "B",
                "text": "scheduleAtFixedRate()"
            },
            {
                "letter": "C",
                "text": "scheduleWithFixedDelay()"
            },
            {
                "letter": "D",
                "text": "submit()"
            }
        ],
        "correct": "B",
        "explanation": "scheduleAtFixedRate() runs tasks repeatedly at a fixed rate."
    },
    {
        "title": "ThreadPools - Q0023",
        "text": "Which method schedules a task to run repeatedly with a fixed delay between executions",
        "options": [
            {
                "letter": "A",
                "text": "schedule()"
            },
            {
                "letter": "B",
                "text": "scheduleAtFixedRate()"
            },
            {
                "letter": "C",
                "text": "scheduleWithFixedDelay()"
            },
            {
                "letter": "D",
                "text": "submit()"
            }
        ],
        "correct": "C",
        "explanation": "scheduleWithFixedDelay() runs tasks with a fixed delay between executions."
    },
    {
        "title": "ThreadPools - Q0024",
        "text": "Which class implements ScheduledExecutorService",
        "options": [
            {
                "letter": "A",
                "text": "ThreadPoolExecutor"
            },
            {
                "letter": "B",
                "text": "ScheduledThreadPoolExecutor"
            },
            {
                "letter": "C",
                "text": "ForkJoinPool"
            },
            {
                "letter": "D",
                "text": "Executors"
            }
        ],
        "correct": "B",
        "explanation": "ScheduledThreadPoolExecutor implements ScheduledExecutorService."
    },
    {
        "title": "ThreadPools - Q0025",
        "text": "What happens if a task is submitted after shutdown() is called",
        "options": [
            {
                "letter": "A",
                "text": "It is executed immediately"
            },
            {
                "letter": "B",
                "text": "It is queued but never executed"
            },
            {
                "letter": "C",
                "text": "It throws RejectedExecutionException"
            },
            {
                "letter": "D",
                "text": "It is ignored silently"
            }
        ],
        "correct": "C",
        "explanation": "Submitting tasks after shutdown() throws RejectedExecutionException."
    },
    {
        "title": "ThreadPools - Q0026",
        "text": "Which policy handles tasks that cannot be executed by a ThreadPoolExecutor",
        "options": [
            {
                "letter": "A",
                "text": "RejectedExecutionHandler"
            },
            {
                "letter": "B",
                "text": "ExecutionPolicy"
            },
            {
                "letter": "C",
                "text": "TaskHandler"
            },
            {
                "letter": "D",
                "text": "ThreadPolicy"
            }
        ],
        "correct": "A",
        "explanation": "RejectedExecutionHandler handles tasks that cannot be executed."
    },
    {
        "title": "ThreadPools - Q0027",
        "text": "Which is the default RejectedExecutionHandler in ThreadPoolExecutor",
        "options": [
            {
                "letter": "A",
                "text": "AbortPolicy"
            },
            {
                "letter": "B",
                "text": "CallerRunsPolicy"
            },
            {
                "letter": "C",
                "text": "DiscardPolicy"
            },
            {
                "letter": "D",
                "text": "DiscardOldestPolicy"
            }
        ],
        "correct": "A",
        "explanation": "AbortPolicy is the default handler, which throws RejectedExecutionException."
    },
    {
        "title": "ThreadPools - Q0028",
        "text": "Which RejectedExecutionHandler runs the task in the callers thread",
        "options": [
            {
                "letter": "A",
                "text": "AbortPolicy"
            },
            {
                "letter": "B",
                "text": "CallerRunsPolicy"
            },
            {
                "letter": "C",
                "text": "DiscardPolicy"
            },
            {
                "letter": "D",
                "text": "DiscardOldestPolicy"
            }
        ],
        "correct": "B",
        "explanation": "CallerRunsPolicy runs the task in the callers thread."
    },
    {
        "title": "ThreadPools - Q0029",
        "text": "Which RejectedExecutionHandler silently discards the rejected task",
        "options": [
            {
                "letter": "A",
                "text": "AbortPolicy"
            },
            {
                "letter": "B",
                "text": "CallerRunsPolicy"
            },
            {
                "letter": "C",
                "text": "DiscardPolicy"
            },
            {
                "letter": "D",
                "text": "DiscardOldestPolicy"
            }
        ],
        "correct": "C",
        "explanation": "DiscardPolicy silently discards the rejected task."
    },
    {
        "title": "ThreadPools - Q0030",
        "text": "Which RejectedExecutionHandler discards the oldest unhandled task",
        "options": [
            {
                "letter": "A",
                "text": "AbortPolicy"
            },
            {
                "letter": "B",
                "text": "CallerRunsPolicy"
            },
            {
                "letter": "C",
                "text": "DiscardPolicy"
            },
            {
                "letter": "D",
                "text": "DiscardOldestPolicy"
            }
        ],
        "correct": "D",
        "explanation": "DiscardOldestPolicy discards the oldest unhandled task in the queue."
    },
    {
        "title": "ThreadPools - Q0031",
        "text": "Which method returns the number of active threads in ThreadPoolExecutor",
        "options": [
            {
                "letter": "A",
                "text": "getActiveCount()"
            },
            {
                "letter": "B",
                "text": "getThreadCount()"
            },
            {
                "letter": "C",
                "text": "getRunningCount()"
            },
            {
                "letter": "D",
                "text": "getSize()"
            }
        ],
        "correct": "A",
        "explanation": "getActiveCount() returns the number of active threads."
    },
    {
        "title": "ThreadPools - Q0032",
        "text": "Which method returns the largest number of threads ever simultaneously in the pool",
        "options": [
            {
                "letter": "A",
                "text": "getLargestPoolSize()"
            },
            {
                "letter": "B",
                "text": "getMaximumPoolSize()"
            },
            {
                "letter": "C",
                "text": "getCorePoolSize()"
            },
            {
                "letter": "D",
                "text": "getThreadCount()"
            }
        ],
        "correct": "A",
        "explanation": "getLargestPoolSize() returns the largest number of threads ever in the pool."
    },
    {
        "title": "ThreadPools - Q0033",
        "text": "Which method returns the current number of threads in the pool",
        "options": [
            {
                "letter": "A",
                "text": "getPoolSize()"
            },
            {
                "letter": "B",
                "text": "getThreadCount()"
            },
            {
                "letter": "C",
                "text": "getActiveCount()"
            },
            {
                "letter": "D",
                "text": "getSize()"
            }
        ],
        "correct": "A",
        "explanation": "getPoolSize() returns the current number of threads in the pool."
    },
    {
        "title": "ThreadPools - Q0034",
        "text": "Which method returns the number of tasks completed by the pool",
        "options": [
            {
                "letter": "A",
                "text": "getCompletedTaskCount()"
            },
            {
                "letter": "B",
                "text": "getTaskCount()"
            },
            {
                "letter": "C",
                "text": "getActiveCount()"
            },
            {
                "letter": "D",
                "text": "getFinishedCount()"
            }
        ],
        "correct": "A",
        "explanation": "getCompletedTaskCount() returns the number of completed tasks."
    },
    {
        "title": "ThreadPools - Q0035",
        "text": "Which method returns the approximate total number of tasks ever scheduled",
        "options": [
            {
                "letter": "A",
                "text": "getCompletedTaskCount()"
            },
            {
                "letter": "B",
                "text": "getTaskCount()"
            },
            {
                "letter": "C",
                "text": "getActiveCount()"
            },
            {
                "letter": "D",
                "text": "getScheduledCount()"
            }
        ],
        "correct": "B",
        "explanation": "getTaskCount() returns the approximate total number of tasks scheduled."
    },
    {
        "title": "ThreadPools - Q0036",
        "text": "Which method allows changing the core pool size of ThreadPoolExecutor",
        "options": [
            {
                "letter": "A",
                "text": "setCorePoolSize()"
            },
            {
                "letter": "B",
                "text": "setPoolSize()"
            },
            {
                "letter": "C",
                "text": "setThreadCount()"
            },
            {
                "letter": "D",
                "text": "setSize()"
            }
        ],
        "correct": "A",
        "explanation": "setCorePoolSize() changes the core pool size."
    },
    {
        "title": "ThreadPools - Q0037",
        "text": "Which method allows changing the maximum pool size of ThreadPoolExecutor",
        "options": [
            {
                "letter": "A",
                "text": "setMaximumPoolSize()"
            },
            {
                "letter": "B",
                "text": "setPoolSize()"
            },
            {
                "letter": "C",
                "text": "setThreadCount()"
            },
            {
                "letter": "D",
                "text": "setSize()"
            }
        ],
        "correct": "A",
        "explanation": "setMaximumPoolSize() changes the maximum pool size."
    },
    {
        "title": "ThreadPools - Q0038",
        "text": "Which method allows changing the keep-alive time of idle threads",
        "options": [
            {
                "letter": "A",
                "text": "setKeepAliveTime()"
            },
            {
                "letter": "B",
                "text": "setIdleTime()"
            },
            {
                "letter": "C",
                "text": "setTimeout()"
            },
            {
                "letter": "D",
                "text": "setDelay()"
            }
        ],
        "correct": "A",
        "explanation": "setKeepAliveTime() changes the keep-alive time of idle threads."
    },
    {
        "title": "ThreadPools - Q0039",
        "text": "Which method pre-starts all core threads in ThreadPoolExecutor",
        "options": [
            {
                "letter": "A",
                "text": "prestartAllCoreThreads()"
            },
            {
                "letter": "B",
                "text": "startAllThreads()"
            },
            {
                "letter": "C",
                "text": "initializeThreads()"
            },
            {
                "letter": "D",
                "text": "warmUp()"
            }
        ],
        "correct": "A",
        "explanation": "prestartAllCoreThreads() starts all core threads before tasks are submitted."
    },
    {
        "title": "ThreadPools - Q0040",
        "text": "Which method pre-starts a single core thread in ThreadPoolExecutor",
        "options": [
            {
                "letter": "A",
                "text": "prestartCoreThread()"
            },
            {
                "letter": "B",
                "text": "startThread()"
            },
            {
                "letter": "C",
                "text": "initializeThread()"
            },
            {
                "letter": "D",
                "text": "warmUpThread()"
            }
        ],
        "correct": "A",
        "explanation": "prestartCoreThread() starts a single core thread before tasks are submitted."
    },
    {
        "title": "ThreadPools - Q0041",
        "text": "Which method removes a task from the work queue if not yet executed",
        "options": [
            {
                "letter": "A",
                "text": "remove()"
            },
            {
                "letter": "B",
                "text": "cancel()"
            },
            {
                "letter": "C",
                "text": "discard()"
            },
            {
                "letter": "D",
                "text": "delete()"
            }
        ],
        "correct": "A",
        "explanation": "remove() removes a task from the work queue if not yet executed."
    },
    {
        "title": "ThreadPools - Q0042",
        "text": "Which method purges cancelled tasks from the work queue",
        "options": [
            {
                "letter": "A",
                "text": "purge()"
            },
            {
                "letter": "B",
                "text": "clean()"
            },
            {
                "letter": "C",
                "text": "clear()"
            },
            {
                "letter": "D",
                "text": "flush()"
            }
        ],
        "correct": "A",
        "explanation": "purge() removes cancelled tasks from the work queue."
    },
    {
        "title": "ThreadPools - Q0043",
        "text": "Which thread pool is best suited for lightweight, short-lived tasks",
        "options": [
            {
                "letter": "A",
                "text": "FixedThreadPool"
            },
            {
                "letter": "B",
                "text": "CachedThreadPool"
            },
            {
                "letter": "C",
                "text": "ScheduledThreadPool"
            },
            {
                "letter": "D",
                "text": "SingleThreadExecutor"
            }
        ],
        "correct": "B",
        "explanation": "CachedThreadPool is best for lightweight, short-lived tasks."
    },
    {
        "title": "ThreadPools - Q0044",
        "text": "Which thread pool guarantees tasks are executed sequentially",
        "options": [
            {
                "letter": "A",
                "text": "FixedThreadPool"
            },
            {
                "letter": "B",
                "text": "CachedThreadPool"
            },
            {
                "letter": "C",
                "text": "ScheduledThreadPool"
            },
            {
                "letter": "D",
                "text": "SingleThreadExecutor"
            }
        ],
        "correct": "D",
        "explanation": "SingleThreadExecutor guarantees sequential execution of tasks."
    },
    {
        "title": "ThreadPools - Q0045",
        "text": "Which thread pool is best for CPU-intensive tasks",
        "options": [
            {
                "letter": "A",
                "text": "FixedThreadPool"
            },
            {
                "letter": "B",
                "text": "CachedThreadPool"
            },
            {
                "letter": "C",
                "text": "ScheduledThreadPool"
            },
            {
                "letter": "D",
                "text": "SingleThreadExecutor"
            }
        ],
        "correct": "A",
        "explanation": "FixedThreadPool is best for CPU-intensive tasks to limit thread count."
    },
    {
        "title": "ThreadPools - Q0046",
        "text": "Which thread pool is best for I/O-bound tasks",
        "options": [
            {
                "letter": "A",
                "text": "FixedThreadPool"
            },
            {
                "letter": "B",
                "text": "CachedThreadPool"
            },
            {
                "letter": "C",
                "text": "ScheduledThreadPool"
            },
            {
                "letter": "D",
                "text": "SingleThreadExecutor"
            }
        ],
        "correct": "B",
        "explanation": "CachedThreadPool is suitable for I/O-bound tasks with variable load."
    },
    {
        "title": "ThreadPools - Q0047",
        "text": "Which method checks if an ExecutorService is shut down",
        "options": [
            {
                "letter": "A",
                "text": "isShutdown()"
            },
            {
                "letter": "B",
                "text": "isTerminated()"
            },
            {
                "letter": "C",
                "text": "isClosed()"
            },
            {
                "letter": "D",
                "text": "isStopped()"
            }
        ],
        "correct": "A",
        "explanation": "isShutdown() checks if shutdown() has been called."
    },
    {
        "title": "ThreadPools - Q0048",
        "text": "Which method checks if all tasks have completed after shutdown",
        "options": [
            {
                "letter": "A",
                "text": "isShutdown()"
            },
            {
                "letter": "B",
                "text": "isTerminated()"
            },
            {
                "letter": "C",
                "text": "isClosed()"
            },
            {
                "letter": "D",
                "text": "isStopped()"
            }
        ],
        "correct": "B",
        "explanation": "isTerminated() checks if all tasks have completed after shutdown."
    },
    {
        "title": "ThreadPools - Q0049",
        "text": "Which method allows submitting Callable tasks to ExecutorService",
        "options": [
            {
                "letter": "A",
                "text": "submit()"
            },
            {
                "letter": "B",
                "text": "execute()"
            },
            {
                "letter": "C",
                "text": "invokeAll()"
            },
            {
                "letter": "D",
                "text": "invokeAny()"
            }
        ],
        "correct": "A",
        "explanation": "submit() allows submitting Callable tasks and returns a Future."
    },
    {
        "title": "ThreadPools - Q0050",
        "text": "Which class is used for parallelism in divide-and-conquer algorithms",
        "options": [
            {
                "letter": "A",
                "text": "ThreadPoolExecutor"
            },
            {
                "letter": "B",
                "text": "ForkJoinPool"
            },
            {
                "letter": "C",
                "text": "ScheduledThreadPoolExecutor"
            },
            {
                "letter": "D",
                "text": "Executors"
            }
        ],
        "correct": "B",
        "explanation": "ForkJoinPool is used for parallelism in divide-and-conquer algorithms."
    },
    {
        "title": "ConcurrentUtilities - Q0001",
        "text": "Which package provides Java concurrent utilities",
        "options": [
            {
                "letter": "A",
                "text": "java.lang"
            },
            {
                "letter": "B",
                "text": "java.util.concurrent"
            },
            {
                "letter": "C",
                "text": "java.thread"
            },
            {
                "letter": "D",
                "text": "java.concurrent"
            }
        ],
        "correct": "B",
        "explanation": "The java.util.concurrent package provides concurrent utilities."
    },
    {
        "title": "ConcurrentUtilities - Q0002",
        "text": "Which class provides atomic operations on integers",
        "options": [
            {
                "letter": "A",
                "text": "Integer"
            },
            {
                "letter": "B",
                "text": "AtomicInteger"
            },
            {
                "letter": "C",
                "text": "AtomicNumber"
            },
            {
                "letter": "D",
                "text": "ConcurrentInteger"
            }
        ],
        "correct": "B",
        "explanation": "AtomicInteger provides atomic operations on integers."
    },
    {
        "title": "ConcurrentUtilities - Q0003",
        "text": "Which class provides atomic operations on boolean values",
        "options": [
            {
                "letter": "A",
                "text": "Boolean"
            },
            {
                "letter": "B",
                "text": "AtomicBoolean"
            },
            {
                "letter": "C",
                "text": "ConcurrentBoolean"
            },
            {
                "letter": "D",
                "text": "AtomicFlag"
            }
        ],
        "correct": "B",
        "explanation": "AtomicBoolean provides atomic operations on boolean values."
    },
    {
        "title": "ConcurrentUtilities - Q0004",
        "text": "Which class provides atomic operations on long values",
        "options": [
            {
                "letter": "A",
                "text": "AtomicLong"
            },
            {
                "letter": "B",
                "text": "Long"
            },
            {
                "letter": "C",
                "text": "ConcurrentLong"
            },
            {
                "letter": "D",
                "text": "AtomicNumber"
            }
        ],
        "correct": "A",
        "explanation": "AtomicLong provides atomic operations on long values."
    },
    {
        "title": "ConcurrentUtilities - Q0005",
        "text": "Which concurrent collection is a thread-safe alternative to HashMap",
        "options": [
            {
                "letter": "A",
                "text": "ConcurrentHashMap"
            },
            {
                "letter": "B",
                "text": "Hashtable"
            },
            {
                "letter": "C",
                "text": "SynchronizedMap"
            },
            {
                "letter": "D",
                "text": "TreeMap"
            }
        ],
        "correct": "A",
        "explanation": "ConcurrentHashMap is a thread-safe alternative to HashMap."
    },
    {
        "title": "ConcurrentUtilities - Q0006",
        "text": "Which concurrent collection allows safe iteration without locking",
        "options": [
            {
                "letter": "A",
                "text": "Vector"
            },
            {
                "letter": "B",
                "text": "CopyOnWriteArrayList"
            },
            {
                "letter": "C",
                "text": "Hashtable"
            },
            {
                "letter": "D",
                "text": "SynchronizedList"
            }
        ],
        "correct": "B",
        "explanation": "CopyOnWriteArrayList allows safe iteration without explicit locking."
    },
    {
        "title": "ConcurrentUtilities - Q0007",
        "text": "Which concurrent collection is a thread-safe queue",
        "options": [
            {
                "letter": "A",
                "text": "ConcurrentLinkedQueue"
            },
            {
                "letter": "B",
                "text": "ArrayList"
            },
            {
                "letter": "C",
                "text": "LinkedList"
            },
            {
                "letter": "D",
                "text": "TreeSet"
            }
        ],
        "correct": "A",
        "explanation": "ConcurrentLinkedQueue is a thread-safe queue implementation."
    },
    {
        "title": "ConcurrentUtilities - Q0008",
        "text": "Which concurrent collection is a thread-safe deque",
        "options": [
            {
                "letter": "A",
                "text": "ConcurrentLinkedDeque"
            },
            {
                "letter": "B",
                "text": "ArrayDeque"
            },
            {
                "letter": "C",
                "text": "LinkedList"
            },
            {
                "letter": "D",
                "text": "Vector"
            }
        ],
        "correct": "A",
        "explanation": "ConcurrentLinkedDeque is a thread-safe deque implementation."
    },
    {
        "title": "ConcurrentUtilities - Q0009",
        "text": "Which concurrent collection is a blocking queue",
        "options": [
            {
                "letter": "A",
                "text": "LinkedBlockingQueue"
            },
            {
                "letter": "B",
                "text": "ArrayList"
            },
            {
                "letter": "C",
                "text": "HashSet"
            },
            {
                "letter": "D",
                "text": "TreeMap"
            }
        ],
        "correct": "A",
        "explanation": "LinkedBlockingQueue is a blocking queue implementation."
    },
    {
        "title": "ConcurrentUtilities - Q0010",
        "text": "Which concurrent collection orders elements based on priority",
        "options": [
            {
                "letter": "A",
                "text": "PriorityBlockingQueue"
            },
            {
                "letter": "B",
                "text": "ConcurrentLinkedQueue"
            },
            {
                "letter": "C",
                "text": "LinkedBlockingQueue"
            },
            {
                "letter": "D",
                "text": "ArrayBlockingQueue"
            }
        ],
        "correct": "A",
        "explanation": "PriorityBlockingQueue orders elements based on priority."
    },
    {
        "title": "ConcurrentUtilities - Q0011",
        "text": "Which synchronization utility allows a fixed number of threads to access a resource",
        "options": [
            {
                "letter": "A",
                "text": "Semaphore"
            },
            {
                "letter": "B",
                "text": "CountDownLatch"
            },
            {
                "letter": "C",
                "text": "CyclicBarrier"
            },
            {
                "letter": "D",
                "text": "Exchanger"
            }
        ],
        "correct": "A",
        "explanation": "Semaphore controls the number of threads accessing a resource."
    },
    {
        "title": "ConcurrentUtilities - Q0012",
        "text": "Which synchronization utility allows threads to wait until a set of operations complete",
        "options": [
            {
                "letter": "A",
                "text": "Semaphore"
            },
            {
                "letter": "B",
                "text": "CountDownLatch"
            },
            {
                "letter": "C",
                "text": "CyclicBarrier"
            },
            {
                "letter": "D",
                "text": "Exchanger"
            }
        ],
        "correct": "B",
        "explanation": "CountDownLatch allows threads to wait until a set of operations complete."
    },
    {
        "title": "ConcurrentUtilities - Q0013",
        "text": "Which synchronization utility allows a group of threads to wait for each other to reach a common barrier point",
        "options": [
            {
                "letter": "A",
                "text": "Semaphore"
            },
            {
                "letter": "B",
                "text": "CountDownLatch"
            },
            {
                "letter": "C",
                "text": "CyclicBarrier"
            },
            {
                "letter": "D",
                "text": "Exchanger"
            }
        ],
        "correct": "C",
        "explanation": "CyclicBarrier allows a group of threads to wait for each other at a barrier point."
    },
    {
        "title": "ConcurrentUtilities - Q0014",
        "text": "Which synchronization utility allows two threads to exchange data",
        "options": [
            {
                "letter": "A",
                "text": "Semaphore"
            },
            {
                "letter": "B",
                "text": "CountDownLatch"
            },
            {
                "letter": "C",
                "text": "CyclicBarrier"
            },
            {
                "letter": "D",
                "text": "Exchanger"
            }
        ],
        "correct": "D",
        "explanation": "Exchanger allows two threads to exchange data objects."
    },
    {
        "title": "ConcurrentUtilities - Q0015",
        "text": "Which synchronization utility allows multiple readers but only one writer",
        "options": [
            {
                "letter": "A",
                "text": "ReentrantLock"
            },
            {
                "letter": "B",
                "text": "ReadWriteLock"
            },
            {
                "letter": "C",
                "text": "Semaphore"
            },
            {
                "letter": "D",
                "text": "CountDownLatch"
            }
        ],
        "correct": "B",
        "explanation": "ReadWriteLock allows multiple readers but only one writer."
    },
    {
        "title": "ConcurrentUtilities - Q0016",
        "text": "Which implementation of ReadWriteLock is provided in Java",
        "options": [
            {
                "letter": "A",
                "text": "ReentrantReadWriteLock"
            },
            {
                "letter": "B",
                "text": "SimpleReadWriteLock"
            },
            {
                "letter": "C",
                "text": "ConcurrentReadWriteLock"
            },
            {
                "letter": "D",
                "text": "AtomicReadWriteLock"
            }
        ],
        "correct": "A",
        "explanation": "ReentrantReadWriteLock is the standard implementation of ReadWriteLock."
    },
    {
        "title": "ConcurrentUtilities - Q0017",
        "text": "Which class provides a thread-safe counter with atomic increment and decrement",
        "options": [
            {
                "letter": "A",
                "text": "AtomicCounter"
            },
            {
                "letter": "B",
                "text": "AtomicInteger"
            },
            {
                "letter": "C",
                "text": "ConcurrentCounter"
            },
            {
                "letter": "D",
                "text": "AtomicLong"
            }
        ],
        "correct": "B",
        "explanation": "AtomicInteger provides atomic increment and decrement operations."
    },
    {
        "title": "ConcurrentUtilities - Q0018",
        "text": "Which class provides a scalable thread-safe random number generator",
        "options": [
            {
                "letter": "A",
                "text": "Random"
            },
            {
                "letter": "B",
                "text": "ThreadLocalRandom"
            },
            {
                "letter": "C",
                "text": "SecureRandom"
            },
            {
                "letter": "D",
                "text": "ConcurrentRandom"
            }
        ],
        "correct": "B",
        "explanation": "ThreadLocalRandom provides a scalable random number generator for concurrent use."
    },
    {
        "title": "ConcurrentUtilities - Q0019",
        "text": "Which class supports fork/join parallelism",
        "options": [
            {
                "letter": "A",
                "text": "ThreadPoolExecutor"
            },
            {
                "letter": "B",
                "text": "ForkJoinPool"
            },
            {
                "letter": "C",
                "text": "ScheduledThreadPoolExecutor"
            },
            {
                "letter": "D",
                "text": "Executors"
            }
        ],
        "correct": "B",
        "explanation": "ForkJoinPool supports fork/join parallelism for divide-and-conquer tasks."
    },
    {
        "title": "ConcurrentUtilities - Q0020",
        "text": "Which class represents a task that can be split into smaller subtasks in ForkJoinPool",
        "options": [
            {
                "letter": "A",
                "text": "RecursiveTask"
            },
            {
                "letter": "B",
                "text": "RecursiveAction"
            },
            {
                "letter": "C",
                "text": "Callable"
            },
            {
                "letter": "D",
                "text": "Runnable"
            }
        ],
        "correct": "A",
        "explanation": "RecursiveTask represents a task that returns a result and can be split into subtasks."
    },
    {
        "title": "ConcurrentUtilities - Q0021",
        "text": "Which ForkJoin class is used for tasks that do not return a result",
        "options": [
            {
                "letter": "A",
                "text": "RecursiveTask"
            },
            {
                "letter": "B",
                "text": "RecursiveAction"
            },
            {
                "letter": "C",
                "text": "Callable"
            },
            {
                "letter": "D",
                "text": "Runnable"
            }
        ],
        "correct": "B",
        "explanation": "RecursiveAction is used for tasks that do not return a result."
    },
    {
        "title": "ConcurrentUtilities - Q0022",
        "text": "Which concurrent queue does not allow null elements",
        "options": [
            {
                "letter": "A",
                "text": "ConcurrentLinkedQueue"
            },
            {
                "letter": "B",
                "text": "LinkedBlockingQueue"
            },
            {
                "letter": "C",
                "text": "PriorityBlockingQueue"
            },
            {
                "letter": "D",
                "text": "All of the above"
            }
        ],
        "correct": "D",
        "explanation": "All concurrent queues in java.util.concurrent disallow null elements."
    },
    {
        "title": "ConcurrentUtilities - Q0023",
        "text": "Which blocking queue has a fixed capacity",
        "options": [
            {
                "letter": "A",
                "text": "ArrayBlockingQueue"
            },
            {
                "letter": "B",
                "text": "LinkedBlockingQueue"
            },
            {
                "letter": "C",
                "text": "PriorityBlockingQueue"
            },
            {
                "letter": "D",
                "text": "ConcurrentLinkedQueue"
            }
        ],
        "correct": "A",
        "explanation": "ArrayBlockingQueue has a fixed capacity defined at creation."
    },
    {
        "title": "ConcurrentUtilities - Q0024",
        "text": "Which blocking queue has optionally bounded capacity",
        "options": [
            {
                "letter": "A",
                "text": "ArrayBlockingQueue"
            },
            {
                "letter": "B",
                "text": "LinkedBlockingQueue"
            },
            {
                "letter": "C",
                "text": "PriorityBlockingQueue"
            },
            {
                "letter": "D",
                "text": "SynchronousQueue"
            }
        ],
        "correct": "B",
        "explanation": "LinkedBlockingQueue can be optionally bounded or unbounded."
    },
    {
        "title": "ConcurrentUtilities - Q0025",
        "text": "Which queue has zero capacity and transfers elements directly between threads",
        "options": [
            {
                "letter": "A",
                "text": "ArrayBlockingQueue"
            },
            {
                "letter": "B",
                "text": "LinkedBlockingQueue"
            },
            {
                "letter": "C",
                "text": "SynchronousQueue"
            },
            {
                "letter": "D",
                "text": "PriorityBlockingQueue"
            }
        ],
        "correct": "C",
        "explanation": "SynchronousQueue has zero capacity and transfers elements directly between threads."
    },
    {
        "title": "ConcurrentUtilities - Q0026",
        "text": "Which concurrent collection maintains elements in sorted order",
        "options": [
            {
                "letter": "A",
                "text": "ConcurrentSkipListMap"
            },
            {
                "letter": "B",
                "text": "ConcurrentHashMap"
            },
            {
                "letter": "C",
                "text": "ConcurrentLinkedQueue"
            },
            {
                "letter": "D",
                "text": "CopyOnWriteArrayList"
            }
        ],
        "correct": "A",
        "explanation": "ConcurrentSkipListMap maintains elements in sorted order."
    },
    {
        "title": "ConcurrentUtilities - Q0027",
        "text": "Which concurrent collection is a sorted set",
        "options": [
            {
                "letter": "A",
                "text": "ConcurrentSkipListSet"
            },
            {
                "letter": "B",
                "text": "ConcurrentHashMap"
            },
            {
                "letter": "C",
                "text": "ConcurrentLinkedQueue"
            },
            {
                "letter": "D",
                "text": "CopyOnWriteArraySet"
            }
        ],
        "correct": "A",
        "explanation": "ConcurrentSkipListSet is a thread-safe sorted set."
    },
    {
        "title": "ConcurrentUtilities - Q0028",
        "text": "Which concurrent collection is backed by a CopyOnWriteArrayList",
        "options": [
            {
                "letter": "A",
                "text": "CopyOnWriteArraySet"
            },
            {
                "letter": "B",
                "text": "ConcurrentSkipListSet"
            },
            {
                "letter": "C",
                "text": "ConcurrentHashMap"
            },
            {
                "letter": "D",
                "text": "ConcurrentLinkedQueue"
            }
        ],
        "correct": "A",
        "explanation": "CopyOnWriteArraySet is backed by a CopyOnWriteArrayList."
    },
    {
        "title": "ConcurrentUtilities - Q0029",
        "text": "Which class provides a synchronization aid that allows one or more threads to wait until a set of operations complete",
        "options": [
            {
                "letter": "A",
                "text": "Semaphore"
            },
            {
                "letter": "B",
                "text": "CountDownLatch"
            },
            {
                "letter": "C",
                "text": "CyclicBarrier"
            },
            {
                "letter": "D",
                "text": "Exchanger"
            }
        ],
        "correct": "B",
        "explanation": "CountDownLatch allows threads to wait until a set of operations complete."
    },
    {
        "title": "ConcurrentUtilities - Q0030",
        "text": "Which class provides a synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point",
        "options": [
            {
                "letter": "A",
                "text": "Semaphore"
            },
            {
                "letter": "B",
                "text": "CountDownLatch"
            },
            {
                "letter": "C",
                "text": "CyclicBarrier"
            },
            {
                "letter": "D",
                "text": "Exchanger"
            }
        ],
        "correct": "C",
        "explanation": "CyclicBarrier allows a set of threads to wait for each other at a barrier point."
    },
    {
        "title": "ConcurrentUtilities - Q0031",
        "text": "Which class provides a synchronization aid that allows two threads to exchange objects",
        "options": [
            {
                "letter": "A",
                "text": "Semaphore"
            },
            {
                "letter": "B",
                "text": "CountDownLatch"
            },
            {
                "letter": "C",
                "text": "CyclicBarrier"
            },
            {
                "letter": "D",
                "text": "Exchanger"
            }
        ],
        "correct": "D",
        "explanation": "Exchanger allows two threads to exchange objects."
    },
    {
        "title": "ConcurrentUtilities - Q0032",
        "text": "Which class provides a synchronization aid that allows a set of parties to repeatedly wait for each other",
        "options": [
            {
                "letter": "A",
                "text": "Semaphore"
            },
            {
                "letter": "B",
                "text": "CountDownLatch"
            },
            {
                "letter": "C",
                "text": "CyclicBarrier"
            },
            {
                "letter": "D",
                "text": "Exchanger"
            }
        ],
        "correct": "C",
        "explanation": "CyclicBarrier can be reused after the barrier is tripped."
    },
    {
        "title": "ConcurrentUtilities - Q0033",
        "text": "Which class provides a synchronization aid that allows threads to wait until a given number of signals are received",
        "options": [
            {
                "letter": "A",
                "text": "Semaphore"
            },
            {
                "letter": "B",
                "text": "CountDownLatch"
            },
            {
                "letter": "C",
                "text": "CyclicBarrier"
            },
            {
                "letter": "D",
                "text": "Exchanger"
            }
        ],
        "correct": "B",
        "explanation": "CountDownLatch allows threads to wait until a given number of signals are received."
    },
    {
        "title": "ConcurrentUtilities - Q0034",
        "text": "Which concurrent utility provides a Phaser for flexible synchronization",
        "options": [
            {
                "letter": "A",
                "text": "Semaphore"
            },
            {
                "letter": "B",
                "text": "Phaser"
            },
            {
                "letter": "C",
                "text": "CyclicBarrier"
            },
            {
                "letter": "D",
                "text": "Exchanger"
            }
        ],
        "correct": "B",
        "explanation": "Phaser provides flexible synchronization for multiple phases."
    },
    {
        "title": "ConcurrentUtilities - Q0035",
        "text": "Which concurrent utility is a more flexible alternative to CyclicBarrier and CountDownLatch",
        "options": [
            {
                "letter": "A",
                "text": "Semaphore"
            },
            {
                "letter": "B",
                "text": "Phaser"
            },
            {
                "letter": "C",
                "text": "Exchanger"
            },
            {
                "letter": "D",
                "text": "ReentrantLock"
            }
        ],
        "correct": "B",
        "explanation": "Phaser is a more flexible alternative to CyclicBarrier and CountDownLatch."
    },
    {
        "title": "ConcurrentUtilities - Q0036",
        "text": "Which concurrent utility provides a thread-safe random number generator",
        "options": [
            {
                "letter": "A",
                "text": "Random"
            },
            {
                "letter": "B",
                "text": "ThreadLocalRandom"
            },
            {
                "letter": "C",
                "text": "SecureRandom"
            },
            {
                "letter": "D",
                "text": "ConcurrentRandom"
            }
        ],
        "correct": "B",
        "explanation": "ThreadLocalRandom provides a thread-safe random number generator."
    },
    {
        "title": "ConcurrentUtilities - Q0037",
        "text": "Which concurrent utility provides a scalable adder for high contention updates",
        "options": [
            {
                "letter": "A",
                "text": "AtomicInteger"
            },
            {
                "letter": "B",
                "text": "LongAdder"
            },
            {
                "letter": "C",
                "text": "AtomicLong"
            },
            {
                "letter": "D",
                "text": "ConcurrentAdder"
            }
        ],
        "correct": "B",
        "explanation": "LongAdder provides scalable updates under high contention."
    },
    {
        "title": "ConcurrentUtilities - Q0038",
        "text": "Which concurrent utility provides a scalable accumulator with a custom function",
        "options": [
            {
                "letter": "A",
                "text": "LongAdder"
            },
            {
                "letter": "B",
                "text": "LongAccumulator"
            },
            {
                "letter": "C",
                "text": "AtomicLong"
            },
            {
                "letter": "D",
                "text": "ConcurrentAccumulator"
            }
        ],
        "correct": "B",
        "explanation": "LongAccumulator provides a scalable accumulator with a custom function."
    },
    {
        "title": "ConcurrentUtilities - Q0039",
        "text": "Which concurrent utility provides a thread-safe class for managing locks",
        "options": [
            {
                "letter": "A",
                "text": "ReentrantLock"
            },
            {
                "letter": "B",
                "text": "Semaphore"
            },
            {
                "letter": "C",
                "text": "CountDownLatch"
            },
            {
                "letter": "D",
                "text": "Phaser"
            }
        ],
        "correct": "A",
        "explanation": "ReentrantLock provides a thread-safe class for managing locks."
    },
    {
        "title": "ConcurrentUtilities - Q0040",
        "text": "Which concurrent utility provides a lock that can be held by multiple readers or one writer",
        "options": [
            {
                "letter": "A",
                "text": "ReentrantLock"
            },
            {
                "letter": "B",
                "text": "ReadWriteLock"
            },
            {
                "letter": "C",
                "text": "Semaphore"
            },
            {
                "letter": "D",
                "text": "Phaser"
            }
        ],
        "correct": "B",
        "explanation": "ReadWriteLock allows multiple readers or one writer."
    },
    {
        "title": "ConcurrentUtilities - Q0041",
        "text": "Which concurrent utility provides a lock with fairness option",
        "options": [
            {
                "letter": "A",
                "text": "ReentrantLock"
            },
            {
                "letter": "B",
                "text": "Semaphore"
            },
            {
                "letter": "C",
                "text": "CountDownLatch"
            },
            {
                "letter": "D",
                "text": "Phaser"
            }
        ],
        "correct": "A",
        "explanation": "ReentrantLock can be constructed with a fairness policy."
    },
    {
        "title": "ConcurrentUtilities - Q0042",
        "text": "Which concurrent utility provides a lock-free thread-safe map",
        "options": [
            {
                "letter": "A",
                "text": "ConcurrentHashMap"
            },
            {
                "letter": "B",
                "text": "Hashtable"
            },
            {
                "letter": "C",
                "text": "SynchronizedMap"
            },
            {
                "letter": "D",
                "text": "TreeMap"
            }
        ],
        "correct": "A",
        "explanation": "ConcurrentHashMap is a lock-free thread-safe map."
    },
    {
        "title": "ConcurrentUtilities - Q0043",
        "text": "Which concurrent utility provides a lock-free thread-safe set",
        "options": [
            {
                "letter": "A",
                "text": "ConcurrentSkipListSet"
            },
            {
                "letter": "B",
                "text": "CopyOnWriteArraySet"
            },
            {
                "letter": "C",
                "text": "HashSet"
            },
            {
                "letter": "D",
                "text": "TreeSet"
            }
        ],
        "correct": "A",
        "explanation": "ConcurrentSkipListSet is a lock-free thread-safe set."
    },
    {
        "title": "ConcurrentUtilities - Q0044",
        "text": "Which concurrent utility provides a thread-safe set backed by a CopyOnWriteArrayList",
        "options": [
            {
                "letter": "A",
                "text": "ConcurrentSkipListSet"
            },
            {
                "letter": "B",
                "text": "CopyOnWriteArraySet"
            },
            {
                "letter": "C",
                "text": "HashSet"
            },
            {
                "letter": "D",
                "text": "TreeSet"
            }
        ],
        "correct": "B",
        "explanation": "CopyOnWriteArraySet is backed by a CopyOnWriteArrayList."
    },
    {
        "title": "ConcurrentUtilities - Q0045",
        "text": "Which concurrent utility provides a thread-safe queue with priority ordering",
        "options": [
            {
                "letter": "A",
                "text": "PriorityBlockingQueue"
            },
            {
                "letter": "B",
                "text": "ConcurrentLinkedQueue"
            },
            {
                "letter": "C",
                "text": "LinkedBlockingQueue"
            },
            {
                "letter": "D",
                "text": "ArrayBlockingQueue"
            }
        ],
        "correct": "A",
        "explanation": "PriorityBlockingQueue provides a thread-safe queue with priority ordering."
    },
    {
        "title": "ConcurrentUtilities - Q0046",
        "text": "Which concurrent utility provides a thread-safe deque",
        "options": [
            {
                "letter": "A",
                "text": "ConcurrentLinkedDeque"
            },
            {
                "letter": "B",
                "text": "ArrayDeque"
            },
            {
                "letter": "C",
                "text": "LinkedList"
            },
            {
                "letter": "D",
                "text": "Vector"
            }
        ],
        "correct": "A",
        "explanation": "ConcurrentLinkedDeque is a thread-safe deque."
    },
    {
        "title": "ConcurrentUtilities - Q0047",
        "text": "Which concurrent utility provides a thread-safe blocking deque",
        "options": [
            {
                "letter": "A",
                "text": "LinkedBlockingDeque"
            },
            {
                "letter": "B",
                "text": "ConcurrentLinkedDeque"
            },
            {
                "letter": "C",
                "text": "ArrayDeque"
            },
            {
                "letter": "D",
                "text": "Vector"
            }
        ],
        "correct": "A",
        "explanation": "LinkedBlockingDeque is a thread-safe blocking deque."
    },
    {
        "title": "ConcurrentUtilities - Q0048",
        "text": "Which concurrent utility provides a scalable thread-safe counter for high contention",
        "options": [
            {
                "letter": "A",
                "text": "AtomicInteger"
            },
            {
                "letter": "B",
                "text": "LongAdder"
            },
            {
                "letter": "C",
                "text": "AtomicLong"
            },
            {
                "letter": "D",
                "text": "ConcurrentCounter"
            }
        ],
        "correct": "B",
        "explanation": "LongAdder is designed for high contention counters."
    },
    {
        "title": "ConcurrentUtilities - Q0049",
        "text": "Which concurrent utility provides a scalable accumulator with a custom function",
        "options": [
            {
                "letter": "A",
                "text": "LongAdder"
            },
            {
                "letter": "B",
                "text": "LongAccumulator"
            },
            {
                "letter": "C",
                "text": "AtomicLong"
            },
            {
                "letter": "D",
                "text": "ConcurrentAccumulator"
            }
        ],
        "correct": "B",
        "explanation": "LongAccumulator provides a scalable accumulator with a custom function."
    },
    {
        "title": "ConcurrentUtilities - Q0050",
        "text": "Which concurrent utility provides a flexible synchronization mechanism for multiple phases",
        "options": [
            {
                "letter": "A",
                "text": "Phaser"
            },
            {
                "letter": "B",
                "text": "CountDownLatch"
            },
            {
                "letter": "C",
                "text": "CyclicBarrier"
            },
            {
                "letter": "D",
                "text": "Semaphore"
            }
        ],
        "correct": "A",
        "explanation": "Phaser provides flexible synchronization for multiple phases."
    }
]
